#!/usr/bin/sandbox-exec -n no-network /usr/bin/ruby -E UTF-8 -v
# -*- coding: utf-8; mode: ruby -*-
#
#  A utility for performing various operations on IPA files.  This script is
#  intended to be invoked by xcodebuild.  It is not intended for direct use,
#  or for invocation in any manner other than through xcodebuild.  Any other
#  use is unsupported.
#
#  Copyright Â© 2015-2017 Apple Inc. All Rights Reserved.
#

GC.disable

require 'optparse'
require 'cfpropertylist'
require 'shellwords'
require 'pathname'
require 'json'
require 'fileutils'
require 'find'
require 'tmpdir'
require 'ostruct'
require 'digest'
require 'sqlite3'
require 'pp'
require 'open3'
require 'set'

$stderr.puts "OS X #{`sw_vers -productVersion`.strip} #{`sw_vers -buildVersion`.strip}"
$stderr.puts "ENV: #{ENV.inspect}"
$stderr.puts "ARGV: #{ARGV.inspect}"

#
# Library
#

# If x fails, print message and backtrace, then exit(1)
def assert(x, message = nil)
  return if x
  $stderr.puts "Assertion failed: #{message}"
  $stderr.puts caller
  exit(1)
end

class Object
  # Useful as a way to add type annotations to code.
  def assert_kind_of(t)
    assert(self.kind_of?(t), "#{self.class} is not kind of #{t}")
  end

  # Useful as a way to add type annotations to code.
  def assert_array_of(t)
    assert_kind_of(Array)
    each{|x| x.assert_kind_of(t) }
  end
end

class Hash

  def self.from_tuples(array)
    ret = self.new
    
    for k,v in array
      ret[k] = v
    end
    
    return ret
  end
  
  # Same as self[k] = v, but raises an exception if self[k] exists.
  def set_once(k, v)
    vOld = self[k]
    raise "Tried to set self[#{k.inspect}] = #{v.inspect}, but it's already set to #{vOld.inspect}." if vOld
    self[k] = v
  end
end

module Enumerable

  def group_using(&eql)
    groups = []

    for x in self
      done = false
      
      for g in groups
        if eql.call(g.first, x)
          g << x
          done = true
          break
        end
      end
      next if done

      groups << [x]
    end
    
    return groups
  end
  
  unless method_defined? :to_h
    def to_h
      return Hash.from_tuples(self)
    end
  end
  
end

class NilClass
  def nil_if_empty
    return nil
  end
end

module Enumerable
  def nil_if_empty
    return nil if self.size == 0
    return self
  end
end

class String
  def nil_if_empty
    return nil if self.size == 0
    return self
  end
end

class String
  def indent(level = 1)
    prefix = "    " * level
    return self.lines.
      map{|l| prefix + l}.
      join('') #lines retains \n
  end

  # We still support Ruby 2.0, so we need a workaround for unicode equivalence
  def unicode_equal?(other)
    return CmdSpec.new(locate_tool("python"), ["-c", "import sys; import unicodedata; print(unicodedata.normalize('NFC', sys.argv[1].decode('utf-8')) == unicodedata.normalize('NFC', sys.argv[2].decode('utf-8')))", self, other]).run(0, false, true).strip == "True"
  end
end

class Exception
  def to_log_s
    return "#{self.inspect}\n#{self.backtrace.join("\n").indent}"
  end
end

# Raises if it couldn't find it.
def locate_tool(name, additional_paths = [])
  return name if Pathname.new(name).absolute?
  
  path = (additional_paths||[]).map{|x|x.to_s}.join(File::PATH_SEPARATOR) + File::PATH_SEPARATOR + (ENV["PATH"] || "")
  paths = path.split(File::PATH_SEPARATOR).select{|p| p.nil_if_empty }
  candidates = paths.map{|p| p + "/" + name}
  
  result = candidates.detect{|p| File.executable?(p) }
  
  raise "Couldn't locate #{name.shellescape} in #{paths.shelljoin}" unless result.nil_if_empty
  return result
end

class CmdSpec
  attr_accessor :bin
  attr_accessor :args
  attr_accessor :env
  attr_accessor :chdir

  def initialize(bin, args, env = nil, chdir = nil)
    assert(bin)
    @bin = locate_tool(bin.to_s)
    @args = (args || []).map{|x|x.to_s}
    @env = (env || {}).map{|k,v| [k.to_s, v.to_s] }.to_h
    @chdir = chdir.to_s
  end

  def to_s
    chdir_s = if self.chdir.nil_if_empty then "cd #{self.chdir.shellescape} && " else "" end
    env_s = if self.env.nil_if_empty then self.env.map{|k,v| "#{k.shellescape}=#{v.shellescape} " }.join(' ') else "" end
    args_s = if self.args.nil_if_empty then " #{self.args.shelljoin}" else "" end
    return "#{chdir_s}#{env_s}#{bin.shellescape}#{args_s}"
  end

  def cache_key
    return "#{bin}#{args}#{env}#{chdir}"
  end

  class NonZeroExcitException < StandardError
    attr_reader :cmd_spec
    attr_reader :out_str
    attr_reader :err_str
    attr_reader :status

    def initialize(cmd_spec, out_str, err_str, status)
      @cmd_spec = cmd_spec
      @out_str = out_str
      @err_str = err_str
      @status = status
    end
  end

  # Raises NonZeroExcitException if the process exits with non-zero
  def run(log_indent = 0, verbose_log = true, use_cache = false)
    if use_cache
      $CMD_SPEC_CACHE ||= Hash.new
      key = self.cache_key
      
      cached_value = $CMD_SPEC_CACHE[key]
      if cached_value.nil?
        cached_value = self.run(log_indent, verbose_log, false)
        $CMD_SPEC_CACHE[key] = cached_value
      end
      
      return cached_value
    end
    
    $stderr.puts(self.to_s.indent(log_indent)) if verbose_log
    
    opts = {}
    opts[:chdir] = chdir if self.chdir.nil_if_empty
    out_str, err_str, status = Open3.capture3(self.env, self.bin, *self.args, opts)
    
    s = "#{bin.shellescape} exited with #{status}\nStdout:\n#{out_str.indent}\nStderr:\n#{err_str.indent}"
    $stderr.puts(s.indent(log_indent+1)) if verbose_log
    
    unless status.success?
      raise NonZeroExcitException.new(self, out_str, err_str, status), s
    end
    
    return out_str
  end
  
end


# Resolves and stores a dependency graph for mach-o linkage. It stores an array of MachOImage dependencies per MachOImage.
class LinkageGraph
  # var graph : Hash <MachOImage -> [MachOImage]>

  def initialize
    @graph = Hash.new
  end

  def to_s(parent_path)
    img_to_s = lambda {|img|
      "#{img.machoFile.path.relative_path_from(parent_path)} #{img.arch}"
    }
    
    return @graph.each.map{|k, vs|
      "#{img_to_s.call(k)} ->\n#{vs.map{|v|img_to_s.call(v)}.join("\n").indent}"
    }.join("\n")
  end

  def [](x)
    return @graph[x]
  end

  def []=(x, y)
    return @graph[x] = y
  end

  # Resolve MachOImage dependencies for image.
  #
  #   rpathStack : [Pathname] -- Holds the linker's @rpath stack. This accumulates as we chase further down the dependency tree.
  #   machOsByRealPath : { Pathname : FSMachOFileNode } -- Maps MachO files by real path so that we can resolve linkage paths to objects.
  #   executablePath : Pathname -- Current substitution for @executable_path.
  #   level : Int -- Log indentation level. This accumulates as we chase further down the dependency tree.
  def resolveLoadedDylibs(image, rpathFallbackStack, rpathStack = [], machOsByRealPath = {}, executablePath = nil, level = 0)
    # Did we already process this image?
    return if self[image]

    # If this is an executable, it becomes the new @executable_path
    executablePath = if image.type == "MH_EXECUTE" then image.machoFile.path.parent else executablePath end
    executablePath.assert_kind_of(Pathname) unless executablePath.nil?

    # Add its rpaths to the rpath stack
    rpaths = image.rpaths
    rpaths.assert_array_of(String)

    rpathStack = rpaths.map{|rpath|
      result = nil
      begin
        result = _expandPath(rpath, image, executablePath, [], rpathFallbackStack)
      rescue RuntimeError => e
        EmitWarning(__LINE__, "Failed to resolve rpath for #{image.machoFile.path.basename}: #{e}")
        result = nil
      end
      result
    }.compact + rpathStack
    rpathStack.assert_array_of(Pathname)

    # Resolve its loaded libraries to MachOImage objects
    dylibs = image.loadedDylibs
    dylibs.assert_array_of(String)

    resolvedDylibs = dylibs.
      select{|n| !n.start_with?('/') }. # Skip absolute paths
      map{ |dylibName|
      resolvedImage = nil

      begin
        # Find a matching rpath to resolve against
        expandedPath = _expandPath(dylibName, image, executablePath, rpathStack, rpathFallbackStack).realpath
        # Find a model object
        resolvedMachO = machOsByRealPath[expandedPath] || (raise "Could not find MachO for #{expandedPath}")
        # Pick the best image/slice to link against
        resolvedImage = resolvedMachO.linkableImageForArch(image.arch) || (raise "Could not find image to link for #{image.arch} in #{expandedPath}")
      rescue RuntimeError => e
        EmitWarning(__LINE__, "Failed to resolve linkage dependency #{image.machoFile.path.basename} #{image.arch} -> #{dylibName}: #{e}")
        resolvedImage = nil
      end

      resolvedImage
    }.compact
    resolvedDylibs.assert_array_of(MachOImage)
    
    self[image] = resolvedDylibs
    # $stderr.puts("LinkageGraph << #{image} ->\n#{resolvedDylibs.join("\n").indent}".indent(level))

    # Follow each dependency
    resolvedDylibs.each{|img| resolveLoadedDylibs(img, rpathFallbackStack, rpathStack, machOsByRealPath, executablePath, level + 1) }
  end

  # Expand @rpath/path -> /absolute/path.
  #
  #   path : String - The linkage path to expand.
  #   image : MachOImage - The substitution for @loader_path.
  #   executablePath : Pathname - The substitution for @executable_path.
  #   rpathStack : [Pathname] - Stack of @rpath substitutions.
  def _expandPath(path, image, executablePath, rpathStack, rpathFallbackStack)
    s = path.dup

    if s =~ /^@executable_path/
      raise "Could not resolve @executable_path for #{path} from #{image.machoFile.path.basename}" unless executablePath
      s.gsub!(/^@executable_path/, executablePath.to_s)
    end

    s.gsub!(/^@loader_path/, image.machoFile.path.parent.to_s)

    if s =~ /^@rpath/
      all_rpaths = rpathStack + [LinkageGraph.parent_path_for_macho_binary_or_framework(image.machoFile.path)] + rpathFallbackStack
      s = all_rpaths.map{|rp|
        rp.assert_kind_of(Pathname)
        s.gsub(/^@rpath/, rp.to_s)
      }.find{|p|
        File.exist?(p)
      }

      raise "Could not resolve @rpath in #{path} from #{image.machoFile.path.basename}" if !s
    end

    return Pathname(s)
  end

  def self.parent_path_for_macho_binary_or_framework(binaryPath)
      parent = binaryPath.parent.realpath
      parent = parent.parent if parent.extname.downcase == ".framework"
      return parent
  end
end

CPUArchitecture = Struct.new(
                             # Name, e.g. arm64
                             :name,
                             # An image with this arch can link the following archs into its address space
                             :linkable_architectures,

                             # A CPU of this arch can also run the following archs, in preference order
                             :runnable_architectures,

                             ) do

  def self.all
    return CPU_ARCHITECTURE_ALL
  end

  def self.get(arch)
    return self.all.find{|a| a.name == arch } || (raise "Unknown arch #{arch}")
  end
end

CPU_ARCHITECTURE_ALL =
  [
   CPUArchitecture.new("arm64",  %w(arm64), %w(arm64 armv7s armv7)),
   CPUArchitecture.new("armv7s", %w(armv7s armv7), %w(armv7s armv7)),
   CPUArchitecture.new("armv7k", %w(armv7k), %w(armv7k)),
   CPUArchitecture.new("armv7",  %w(armv7), %w(armv7)),
  ]

class Pathname

  # Creates a new empty file (or directory if opts[:dir]). Fails if a file already exists at path. Returns self.
  def self.createExclusive(path, opts = {})
    path.parent.mkpath()
    if opts[:dir]
      Dir.mkdir(path) {}
    else
      File.open(path, File::WRONLY|File::CREAT|File::EXCL) {}
    end
    return path
  end

  # If path already exists, adds incrementing suffixes until it's unique and can be created with createExclusive(path, opts). Returns the new unique path.
  def self.createUnique(path, opts = {})
    uniquePath = path
    i = 0
    loop do
      suffix = i == 0 ? "" : "-#{i}"
      uniquePath = path.parent + (path.basename.to_s + suffix)
      i += 1
      Pathname.createExclusive(uniquePath, opts) rescue next
      return uniquePath
    end
  end

end

#
#  Parse Options
#
OPTIONS = OpenStruct.new()
OPTIONS.skipThinDevices = []
OPTIONS.verbosity = 1
OPTIONS.useAssetutilEql = true
OPTIONS.validateOutput = false
OPTIONS.validateOutputZeroVariants = nil
OPTIONS.bitcodeOptions = []
USAGE_BANNER = "usage: #{File.basename(__FILE__).shellescape} <ipa-or-dir> [options] [--output=<ipa-or-dir>]"
OptionParser.new do |opts|
  opts.banner = USAGE_BANNER

  opts.on("--info",
          "Prints information about the contents of the IPA") \
  do |v|
    OPTIONS.printInfo = true
  end

  opts.on("--validate",
          "Performs a variety of checks on the input IPA, reporting any errors or warnings on stderr as well as",
          "in the output JSON file (if one is requested)") \
  do |v|
    OPTIONS.validateInput = true
  end

  opts.on("--[no-]compile-bitcode",
          "Compile any bitcode that's in the IPA; if there is none, a warning is emitted but it's not an error",
          "If thinning is also enabled, the Bitcode won't be in any thinned IPAs") \
  do |v|
    OPTIONS.compileBitcode = v
  end

  opts.on("--create-thinned=DEVICE", String,
          "Create thinned IPAs for devices with the given identifier",
          "The identifier is either a device identifier or the special name 'all' to generate all supported variants") \
  do |v|
    OPTIONS.thinDevices ||= []
    OPTIONS.thinDevices << v
  end

  opts.on("--skip-thinned=DEVICE", String,
          "When used with --create-thinned=all, skip this device",
          "This allows --create-thinned=all to exclude certain devices",
          "It can be passed multiple times") \
  do |v|
    OPTIONS.skipThinDevices << v
  end

  opts.on("--create-asset-packs",
          "Create asset packs from any on-demand resources",
          "The asset packs will be created in a directory next to the output",
          "If thinning is also enabled, the created asset packs will also be thinned for each set of traits",
          "If the --asset-manifest-url-prefix option is also provided, and AssetPackManifest.plist will be created") \
  do |v|
    OPTIONS.createAssetPacks = true
  end

  opts.on("--asset-manifest-url-prefix=URL",
          "URL prefix string for URLs in AssetPackManifest.plist",
          "This string will be prepended verbatim to each asset pack URL in generated AssetPackManifest.plist files",
          "Use this option to specify which server and subpath will vend the final, streamable asset packs",
          "If this option is omitted when --create-asset-packs is specified, no AssetPackManifest.plist will be created") \
  do |v|
    OPTIONS.urlPrefix = v
  end

  opts.on("--create-app-placeholders",
          "Create placeholder app bundles for each created application",
          "Placeholders just contain the Info.plist files, with additional information about ODR sizes etc") \
  do |v|
    OPTIONS.createAppPlaceholders = true
  end

  opts.on("-o", "--output=PATH", String,
          "Output path (either an non-thin IPA or directory of thin IPAs, depending on other options)",
          "When thinning, this directory will be created to contain a set of output IPAs",
          "Otherwise, this directory will be the single output IPA") \
  do |v|
    OPTIONS.outputPath = Pathname(v).absolute? ? Pathname(v) : Pathname.getwd() + Pathname(v)
  end

  opts.on("-t", "--tmpdir=PATH", String,
          "Path of directory to use as temporary directory",
          "The directory will be created, if needed, but will not be removed at the end",
          "If this option isn't provided, #{File.basename(__FILE__).shellescape} will create a unique temporary directory and remove it upon exit") \
  do |v|
    OPTIONS.tmpPath = Pathname(v).absolute? ? Pathname(v) : Pathname.getwd() + Pathname(v)
  end

  opts.on("-j", "--jobs=N",
          "Specifies the number of jobs to run simultaneously during bitcode compilation") \
  do |v|
    OPTIONS.bitcodeCompilationJFactor = v.to_i
  end

  opts.on("--toolchain=DIR",
          "Specify the toolchain path, if it isn't in the standard location realtive to ipatool",
          "This is normally not needed when invoking ipatool as part of AppStoreTools, but is used when invoked by Xcode.app") \
  do |v|
    OPTIONS.toolchainDir = Pathname(v).absolute? ? Pathname(v) : Pathname.getwd() + Pathname(v)
  end

  opts.on("--platforms=DIR",
          "Specify the platforms path, if it isn't in the standard location realtive to ipatool",
          "This is normally not needed when invoking ipatool as part of AppStoreTools, but is used when invoked by Xcode.app") \
  do |v|
    OPTIONS.platformsDir = Pathname(v).absolute? ? Pathname(v) : Pathname.getwd() + Pathname(v)
  end

  opts.on("--bitcode-build-option=OPTION",
          "The additional option passed to bitcode-build-tool",
          "This is normally not needed when invoking ipatool as part of AppStoreTools, but is used for bitcode-build-tool debugging") \
  do |v|
    OPTIONS.bitcodeOptions << v
  end

  opts.on("--[no-]use-assetutil-eql") do |v|
    OPTIONS.useAssetutilEql = v
  end

  opts.on("--[no-]validate-output") do |v|
    OPTIONS.validateOutput = v
  end

  opts.on("--[no-]validate-output-zero-variants") do |v|
    OPTIONS.validateOutputZeroVariants = v
  end

  opts.on_tail("--json=OUTPUT",
               "Provide output in JSON format. Other programs invoking #{File.basename(__FILE__).shellescape} are expected to use this option instead",
               "of trying to parse the default format. The output is a sequence of JSON dictionaries representing operations and issues.") \
  do |v|
    begin
      OPTIONS.jsonPipe = (v == "-") ? $stdout : File.open(v, 'w')
    rescue SystemCallError => e
      $stderr.puts "error: couldn't open the specified JSON file (#{e})"
      exit 1
    end
  end

  opts.on_tail("-v", "--verbose",
               "Increase the verbosity level; this option can be specified multiple times, each time making output more verbose") \
  do |v|
    OPTIONS.verbosity += 1
  end

  opts.on_tail("-q", "--quiet",
               "Makes ipatool completely silent; if this option is provided along with -v, the last one wins") \
  do |v|
    OPTIONS.verbosity = 0
  end

  opts.on_tail("--help", "Show this message") do
    puts opts
    exit
  end

end.parse!

if OPTIONS.validateOutputZeroVariants.nil?
  OPTIONS.validateOutputZeroVariants = OPTIONS.validateOutput && OPTIONS.skipThinDevices.empty?
end

#
#  Create Temporary Directory
#
# We might have been given a path for temporary files.  If not, we pick one (respecting 'TMP'), and clean it up at the end.
OPTIONS.tmpPath.mkpath() if OPTIONS.tmpPath
OPTIONS.tmpDir = Pathname(Dir.mktmpdir(File.basename(__FILE__, "rb"), OPTIONS.tmpPath))
at_exit { $stdout.puts "Removing temporary directory #{OPTIONS.tmpDir}..." if OPTIONS.verbosity >= 3 ; OPTIONS.tmpDir.rmtree() } unless OPTIONS.tmpPath
# now options.tmpPath is whatever the user specified, and options.tmpDir is always a directory that exists in the file system


#
#  Configure Structured Output
#
# During processing, structured output is added to the JsonOutput dictionary.
JsonOutput = { }

# Function to emit an error to stderr and also to the JSON output file, if defined.  Note that in a lot of current cases we use the line number as the code.
# This is temporary â in the future we should either define a catalog of errors with assigned numbers, or switch to using alphanumeric identifiers.
$EMITTED_ERRORS = false
def EmitError (code, desc, type = nil, expl = nil, outputHandle = $stderr)
  $EMITTED_ERRORS = true
  outputHandle.puts "error: #{desc}" if outputHandle
  JsonOutput[:alerts] = [] unless JsonOutput[:alerts]
  JsonOutput[:alerts] << { level: "ERROR", type: type, code: code, description: desc, info: {}, explanation: expl }.reject { |k, v| v.nil? } if OPTIONS.jsonPipe
end

# Function to emit a warning to stderr and also to the JSON output file, if defined.
def EmitWarning (code, desc, type = nil, expl = nil, outputHandle = $stderr)
  outputHandle.puts "warning: #{desc}" if outputHandle
  JsonOutput[:alerts] = [] unless JsonOutput[:alerts]
  JsonOutput[:alerts] << { level: "WARN", type: type, code: code, description: desc, info: {}, explanation: expl }.reject { |k, v| v.nil? } if OPTIONS.jsonPipe
end

# Function to emit an informational notice to stderr and also to the JSON output file, if defined.
def EmitInfo (code, desc, type = nil, expl = nil, outputHandle = $stderr)
  outputHandle.puts "info: #{desc}" if outputHandle
  JsonOutput[:alerts] = [] unless JsonOutput[:alerts]
  JsonOutput[:alerts] << { level: "INFO", type: type, code: code, description: desc, info: {}, explanation: expl }.reject { |k, v| v.nil? } if OPTIONS.jsonPipe
end

# Calls EmitError and exits with an error code.
def FatalError (code, desc, exitCode = 1)
  EmitError(code, desc, nil)
  exit(exitCode)
end

# Calls EmitError with a type of "malformed-ipa" without exiting.
def EmitIPAStructureValidationError (desc)
  EmitError(0, desc, "malformed-ipa")
end

# Calls EmitError with a type of "malformed-payload" without exiting.
def EmitIPAPayloadValidationError (desc)
  EmitError(0, desc, "malformed-payload")
end

# Calls EmitError with a type of "malformed-payload" without exiting.
def EmitIPAOutputValidationError (desc)
  EmitError(0, desc, "malformed-output")
end

def LoadPlist(path, parentPathForDisplay = nil)
  relPath = path
  chdir = nil
  begin
    if parentPathForDisplay
      relPath = path.relative_path_from(parentPathForDisplay)
      chdir = parentPathForDisplay if parentPathForDisplay
    end
  rescue => ex
    $stderr.puts "warning: failed to format relative path (#{path}, #{parentPathForDisplay}): #{ex.message}"
    relPath = path
    chdir = nil
  end

  out_str = CmdSpec.new(locate_tool("plutil"), ['-convert', 'binary1', '-o', '-', '--', relPath.to_s], nil, chdir).run(0, false, true)

  pl = CFPropertyList::List.new
  pl.load_str(out_str, CFPropertyList::List::FORMAT_BINARY)
  return pl
end

# Loads a plist and categorizes parse errors as malformed-input.
def LoadUserPlist(path, parentPathForDisplay = nil)
  begin
    return LoadPlist(path, parentPathForDisplay)
  rescue ex
    $stderr.puts "exception: #{ex.to_log_s}"
    EmitIPAPayloadValidationError("Failed to read property list: #{ex.message}")
    exit(1)
  end
end

JsonOutputFormatting = { indent: '  ', space: ' ', object_nl: "\n", array_nl: "\n", max_nesting: false }
at_exit {
  if $! && !$!.kind_of?(SystemExit)
    EmitError(__LINE__, "ipatool failed with an exception: #{$!.to_log_s}", "exception", nil, nil)
  end

  OPTIONS.jsonPipe.puts JSON.generate(JsonOutput, JsonOutputFormatting)
} if OPTIONS.jsonPipe


#
#  Check Arguments
#
# Check that we were given exactly one path: the IPA to operate on (either flattened or expanded).
if ARGV.count == 0
  $stderr.puts USAGE_BANNER
  JsonOutput[:alerts] = [] unless JsonOutput[:alerts]
  JsonOutput[:alerts] << { level: "ERROR", code: -1, description: "error: invalid usage: no arguments provided", info: {}}.reject { |k, v| v.nil? } if OPTIONS.jsonPipe
  exit 1
elsif ARGV.count == 1
  OPTIONS.inputPath = Pathname(ARGV[0])
  if not (OPTIONS.printInfo or OPTIONS.validateInput or OPTIONS.compileBitcode or OPTIONS.thinDevices or OPTIONS.createAssetPacks)
    $stderr.puts "error: no action specified"
    $stderr.puts USAGE_BANNER
    JsonOutput[:alerts] = [] unless JsonOutput[:alerts]
    JsonOutput[:alerts] << { level: "ERROR", code: -1, description: "error: invalid usage: no action specified", info: {}}.reject { |k, v| v.nil? } if OPTIONS.jsonPipe
    exit 1
  end
else
  $stderr.puts "error: too many input files specified"
  $stderr.puts USAGE_BANNER
  JsonOutput[:alerts] = [] unless JsonOutput[:alerts]
  JsonOutput[:alerts] << { level: "ERROR", code: -1, description: "error: invalid usage: too many input files specified", info: {}}.reject { |k, v| v.nil? } if OPTIONS.jsonPipe
  exit 1
end

# If we weren't given a toolchain directory, we try to locate one.
unless OPTIONS.toolchainDir
  #  On the AppStoreTools disk image, the toolchain directory is the parent of the directory that contains ipatool.
  OPTIONS.toolchainDir = Pathname(__dir__).parent
end

# Make sure we did end up with a valid toolchain directory.
unless OPTIONS.toolchainDir.directory?
  FatalError(__LINE__, "toolchain directory #{OPTIONS.toolchainDir} #{OPTIONS.toolchainDir.exist? ? "isn't a directory" : "doesn't exist"}")
end

# Warn if the user specified an asset pack prefix URL that will never get used because asset packs aren't being created.
if OPTIONS.urlPrefix and not OPTIONS.createAssetPacks
  EmitWarning(__LINE__, "asset pack creation not requested, so --asset-manifest-url-prefix is ignored")
end

# If we weren't given a platform directory, we try to locate one.
unless OPTIONS.platformsDir
  #  On the AppStoreTools disk image, the platforms directory is off of the parent directory of the toolchains directory.
  OPTIONS.platformsDir = OPTIONS.toolchainDir.parent + "Platforms"
end

# Make sure we did end up with a valid platforms directory.
unless OPTIONS.platformsDir.directory?
  FatalError(__LINE__, "platforms directory #{OPTIONS.platformsDir} #{OPTIONS.platformsDir.exist? ? "isn't a directory" : "doesn't exist"}")
end

# Prepend the tools directory to the command line search path.
ENV["PATH"] = "#{OPTIONS.toolchainDir}/bin" + ":" + ENV["PATH"]

# Check that we were given an output directory if we're asked to compile bitcode and/or create thinned outputs.
if (OPTIONS.compileBitcode or OPTIONS.thinDevices or OPTIONS.createAssetPacks) and not OPTIONS.outputPath
  actions = []
  actions << "bitcode compilation" if OPTIONS.compileBitcode
  actions << "device-specific thinning" if OPTIONS.thinDevices
  actions << "asset-pack creation" if OPTIONS.createAssetPacks
  FatalError(__LINE__, "#{actions.join(" and ")} requested, but no --output argument provided")
end

if !OPTIONS.skipThinDevices.empty? && OPTIONS.thinDevices != ["all"]
  FatalError(__LINE__, "--skip-thinned is only compatible with --create-thinned=all")
end

#
#  Unpack Flattened IPA (If Needed)
#
# The input path may be either a file or a directory; if it's a file, we unpack it into our temporary directory.
OPTIONS.ipaName = OPTIONS.inputPath.basename
if OPTIONS.inputPath.file?
  # Use 'ditto -x -k' to unpack the IPA (it's really just a Zip file, for now); later we'll use the StreamingZip tool.
  $stdout.puts "Unpacking #{OPTIONS.inputPath.basename.to_s.shellescape}..." if OPTIONS.verbosity >= 3
  unpackedDir = OPTIONS.tmpDir.join("ipa")
  CmdSpec.new("ditto", ["-x", "-k", "--noqtn", "--noacl", OPTIONS.inputPath, unpackedDir]).run(0, false)
  OPTIONS.inputPath = unpackedDir
end

#  Allow us to annotate paths with architectures, when we know them
class Pathname
  attr_accessor  :arch            # Architecture identifier, if applicable (see the arch(3) man page)
end

#
#  Data Model
#

# Represents a single Mach-O image, backed by either a thin file or a slice of a fat file.
class MachOImage
  attr           :type             # Type of file, e.g. MH_EXECUTE, MH_DYLIB, etc
  attr           :platformIdentifier # Platform (macosx, iphoneos, etc)
  attr           :arch             # Architecture, e.g. x86_64 or arm64
  attr           :uuid             # UUID, from the UUID load command
  attr           :hasBitcode       # True if the Mach-O image contains bitcode
  attr           :hasExecCode      # True if the Mach-O image contains executable code
  attr           :isSigned         # True if the Mach-O image is signed
  attr_accessor  :machoFile        # The Mach-O file of which this image is a part (an FSMachOFileNode object)

  def initialize (type, platformIdentifier, arch, uuid, hasBitcode, hasExecCode, isSigned)
    @type = type
    @platformIdentifier = platformIdentifier
    @arch = arch
    @uuid = uuid
    @hasBitcode = hasBitcode
    @hasExecCode = hasExecCode
    @isSigned = isSigned
    @machoFile = nil  # this will be set later, when we're attached to an FSMachOFileNode
  end

  def platform
    return Platform.platformForIdentifer(self.platformIdentifier)
  end

  # We need to override to_s and inspect because MachOImage has a pointer back to its MachOFile and that cycle breaks the default inspect.
  def to_s
    return "<MachOImage #{self.machoFile.path} #{self.arch}>"
  end

  def inspect
    return to_s
  end

  def thinToPath (dstPath, level)
    # Creates a thin Mach-O file at the given path, taking the contents from the Mach-O image that backs this object.
    # If the backing is already thin, we can just copy the file; otherwise we need to use lipo(1) to extract the arch
    # slice into a new thin file.
    dstPath.parent.mkpath()
    unless machoFile.isFat
      # We already have a thin file (either from the start, or because it has already been thinned earlier).
      FileUtils.cp(self.machoFile.path, dstPath)
    else
      # We don't have a thin file, so we use lipo(1) to extract the slice from our Mach-O file.
      CmdSpec.new(locate_tool("lipo", [self.platform.toolsPath]), ["-thin", arch, machoFile.path, "-output", dstPath]).run(level, false)
    end
  end

  def isDylib
    return self.type == 'MH_DYLIB'
  end

  # Where are we storing the thinned version of this image?
  def thinnedPath(ipa, options)
    return self.machoFile.path.reparent(ipa.path, options.tmpDir + "thinned" + self.arch)
  end

  def rawLoadCommands
    @rawLoadCommands ||= CmdSpec.new(locate_tool("otool", [self.platform.toolsPath]), ["-l", "-v", "-m", "-arch", self.arch, self.machoFile.path]).run(0, true, true)
  end

  # Names from LC(_LAZY)?_LOAD(_WEAK)?_DYLIB commands.
  def loadedDylibs
    return rawLoadCommands.
      scan(/cmd LC(_LAZY)?_LOAD(_WEAK)?_DYLIB.*?name\s+(.*?)\s+\(offset\s+\d+\)/m).
      map{|groups| groups[2] }
  end

  def dylibNames
    return self.loadedDylibs.map{|l| l.sub(/^.*\/([^\/]*)$/, '\1') }
  end

  # Paths from LC_RPATH commands.
  def rpaths
    return rawLoadCommands.
      scan(/cmd LC_RPATH.*?path\s+(.*?)\s+\(offset \d+\)/m).
      map{|groups| groups[0] }
  end

  # Should we exclude this image from the output IPA?
  def shouldExcludeFromOutput
    if not defined? @shouldExcludeFromOutput
      @shouldExcludeFromOutput = lambda {
        return !self.machoFile.enclosingBundle.bitcodeCompilationRootMachO.machoImages.any?{ |img|
          img.arch == self.arch
        }
      }.call
    end

    return @shouldExcludeFromOutput
  end

  def shouldCompileBitcode(options)
    return (options.compileBitcode &&
            self.hasBitcode &&
            !self.shouldExcludeFromOutput &&
            self.machoFile.enclosingBundle.bitcodeCompilationRootMachO.machoImages.any? { |img|
              img.hasBitcode && img.arch == self.arch
            })
  end

  def shouldStripBitcode(options)
    return (self.hasBitcode &&
            !self.shouldExcludeFromOutput &&
            (!options.compileBitcode ||
             self.machoFile.enclosingBundle.bitcodeCompilationRootMachO.machoImages.any?{ |img|
               !img.hasBitcode && img.arch == self.arch
             }))
  end
  
end

class Pathname
  # /a/foo reparent from /a to /b => /b/foo
  def reparent(old_parent, new_parent)
    relpath = self.relative_path_from(old_parent) || (raise "#{old_parent} is not a parent of #{self}")
    return new_parent + relpath
  end
end

# Represents a file system entity.
class FSNode
  attr_accessor  :path              # Pathname for the file in the file system (can be relocated in special cases)
  attr           :enclosingBundle   # Reference to the bundle in which we're nested, or nil if we're the top

  def initialize (path, enclosingBundle)
    path = Pathname(path) unless path.kind_of?(Pathname)
    @path = path
    @enclosingBundle = enclosingBundle
  end

  def name
    return path.basename.to_s
  end

  def subnodes
    return nil
  end

end

class FSFileNode < FSNode

  def copyToPath (dstPath, thinningTraits = nil, level = 0)
    puts "#{"  "*level}copy #{name.shellescape}" if OPTIONS.verbosity >= 2

    # Copy the file contents to the destination path.
    FileUtils.cp(path, dstPath)

    # Make the mode of the destination the same as the source.
    dstPath.lchmod(path.stat().mode)
  end

end

class FSSymlinkNode < FSNode

  def copyToPath (dstPath, thinningTraits = nil, level = 0)
    puts "#{"  "*level}slnk #{name.shellescape}" if OPTIONS.verbosity >= 2

    # Copy the file contents to the destination path.
    dstPath.make_symlink(path.readlink())

    # Make the mode of the destination the same as the source.
    dstPath.lchmod(path.stat().mode)
  end

end

class FSDirectoryNode < FSNode
  attr  :subnodes      # Nodes representing the directory contents

  def initialize (path, enclosingBundle)
    super(path, enclosingBundle)
    @subnodes = []
  end

  def copyToPath (dstPath, thinningTraits = nil, level = 0)
    puts "#{"  "*level}mkdr #{name.shellescape}/" if OPTIONS.verbosity >= 2

    # First remove the existing directory, if any.
    dstPath.rmtree() rescue Errno::ENOENT

    # Create the top-level directory and then recurse downward.
    dstPath.mkpath()

    # Copy the file contents to the destination path.
    for subnode in subnodes
      subnode.copyToPath(dstPath + subnode.name, thinningTraits, level + 1)
    end

    # Make the mode of the destination the same as the source.
    dstPath.lchmod(path.stat().mode)
  end

  # Calls block or returns an enumerator with every descendant model object of this directory
  def enumerateTree
    return enum_for(:enumerateTree) unless block_given?
    yield self
    self.subnodes.each { |n|
      if n.respond_to? :enumerateTree
        n.enumerateTree {|n2| yield n2}
      else
        yield n
      end
    }
  end
end

class FSMachOFileNode < FSFileNode
  attr_accessor  :machoImages   # Array of Mach-O images contained in the file (note that even if one, it could be a fat file)
  attr           :type          # MH_EXECUTE, MH_DYLIB, etc (technically an image property, but all should be the same)

  def initialize (path, enclosingBundle, machoImages)
    super(path, enclosingBundle)
    assert(machoImages.size > 0)
    @machoImages = machoImages.each{ |img|img.machoFile = self }
    @type = machoImages.first.type
    # we should warn if we find different types in different slices
  end

  def platform
    return self.machoImages[0].platform
  end

  def isFat
    output = lipo_info(path)

    if output =~ /Architectures in the fat file.*\:(.+)/m
      return true
    elsif output =~ /Non-fat file.*\:(.+)/m
      return false
    else
      raise "Couldn't parse output of #{cmd}: #{output}"
    end
  end

  # Given #arch, pick the best image to link against. Returns nil if we can't link any image in this MachO against #arch.
  def linkableImageForArch(arch)
    # Find the best Mach-O image to use, which matches the earliest linkable architecture.
    return CPUArchitecture.get(arch).linkable_architectures.map { |li|
      machoImages.find { |mi| mi.arch == li }
    }.compact.first
  end

  def linkableImageForArchOrError(arch)
    machoImage = self.linkableImageForArch(arch)
    unless machoImage
      EmitIPAPayloadValidationError("couldn't find suitable architecture for linking #{arch} in Mach-O file #{path.to_s.shellescape}")
      exit(1)
    end
    return machoImage
  end

  def shouldThin
    return self.enclosingBundle.shouldThin
  end

  def copyToPath (dstPath, thinningTraits = nil, level = 0)
    if thinningTraits && self.shouldThin
      puts "#{"  "*level}thin #{name.shellescape}" if OPTIONS.verbosity >= 2

      machoImage = self.linkableImageForArchOrError(thinningTraits.preferredArch)

      # Ask the Mach-O image to emit a thin binary to the destination path.
      machoImage.thinToPath(dstPath, level)

      # Make the mode of the destination the same as the source.
      dstPath.lchmod(path.stat().mode)
    else
      super(dstPath, thinningTraits, level)
    end
  end

  def isDylib
    return machoImages.first.isDylib
  end

  def isSwiftRuntimeDylib
    return isDylib && self.name =~ /libswift.*\.dylib/
  end

  # After we've recompiled each image, where do we store the universal reassembled MachO?
  def universalReassemblyPath(ipa, options)
    return self.path.reparent(ipa.path, options.tmpDir + "universal-MachOs")
  end

end

class FSAssetCatalogFileNode < FSFileNode

  def shouldThin
    return self.enclosingBundle.shouldThin && !self.enclosingBundle.isWatchKitAppExtension
  end

  def copyToPath (dstPath, thinningTraits = nil, level = 0)
    if thinningTraits && self.shouldThin
      puts "#{"  "*level}asct #{name.shellescape}" if OPTIONS.verbosity >= 2

      CmdSpec.new(locate_tool("assetutil", [self.enclosingBundle.platform.toolsPath]),
                  (thinningTraits.to_assetutil_args_array +
                   [
                    "--output=#{dstPath}",
                    path,
                   ])
                  ).run(level)

      # Make the mode of the destination the same as the source.
      dstPath.lchmod(path.stat().mode) rescue Errno::ENOENT
    else
      super(dstPath, thinningTraits, level)
    end
  end

  # Would DeviceTraits a and b produce the same output when they thin this AssetCatalog? A return value of true is conclusive, whereas false is not. It would be too expensive to compute a conclusive no.
  def eql_for_traits?(a, b)
    # - graphicsclassfallbacks and hostedidioms should not be passed to -T
    
    output = CmdSpec.new(locate_tool("assetutil", [self.enclosingBundle.platform.toolsPath]),
                         [
                          "-T",
                          "#{a.to_assetutil_T_string}/#{b.to_assetutil_T_string}",
                          self.path,
                         ]
                         ).run(0, false, true)

    return false if output.start_with?("not equal ")
    if output.start_with?("equal ")
      if a.gfxFeatureSetFallbacks != b.gfxFeatureSetFallbacks
        $stderr.puts ">>>> equal but different fallbacks:\n#{a.to_assetutil_dict}\n#{b.to_assetutil_dict}"
      end
      return true
    end
    raise "Unknown assetutil -T output: #{output}"
  end
  
end

class FSBundleDirectoryNode < FSDirectoryNode
  attr           :infoDict                      # Info.plist contents of the bundle (always a dictionary)
  attr           :requiredDeviceCapabilities    # Set of required device capabilities

  # This class has multi-stage initialization. Anything which uses the below is not safe until initialized is true.
  attr_accessor  :initialized
  attr           :machoFiles                    # Any Mach-O files in the bundle (but not in nested bundles)
  attr_accessor  :mainMachoFile                 # Main executable Mach-O file, nil if none (always included in machoFiles)
  attr           :nestedBundles                 # Any nested bundles (but not any nested bundles inside those bundles)

  def initialize (path, enclosingBundle, infoDict)
    super(path, enclosingBundle)
    @infoDict = infoDict
    # The following properties will be populated by the logic that creates us.
    @machoFiles = []
    @mainMachoFile = nil
    @nestedBundles = []

    # Examine UIRequiredDeviceCapabilities
    @requiredDevCaps = infoDict["UIRequiredDeviceCapabilities"] || {}
    if @requiredDevCaps.kind_of?(Array)
      dict = {}
      for cap in @requiredDevCaps
        dict[cap] = true
      end
      @requiredDevCaps = dict
    end
  end

  def self.getInfoPlistIfPathIsBundle (path, parentPathForDisplay = nil)
    # Check if the given path seems like a bundle, and if so, return its Info.plist contents.
    return nil unless path.directory?
    infoPlistPath = path + "Info.plist"
    return nil unless infoPlistPath.file?
    infoPlist = LoadUserPlist(infoPlistPath, parentPathForDisplay)
    nativeInfoPlist = CFPropertyList::native_types(infoPlist.value) unless infoPlist == nil
    return nil unless nativeInfoPlist && nativeInfoPlist.kind_of?(Hash) && nativeInfoPlist["CFBundleIdentifier"]
    return nativeInfoPlist
  end

  def identifier ()
    return infoDict["CFBundleIdentifier"]
  end

  def supportedIdioms
    if not defined? @supportedIdioms
      @supportedIdioms = lambda {
        family = infoDict["UIDeviceFamily"]
        
        if family.nil_if_empty.nil?
          if self.enclosingBundle && self.platformIdentifier == self.enclosingBundle.platformIdentifier
            return self.enclosingBundle.supportedIdioms
          else
            return nil
          end
        end
        
        return DeviceTraits.assetutil_idioms_for_UIDeviceFamily(family)
      }.call
    end

    return @supportedIdioms
  end

  def statedPlatformIdentifier
    supportedPlatformIdents = infoDict["CFBundleSupportedPlatforms"]

    if self.enclosingBundle && supportedPlatformIdents.nil_if_empty.nil?
      return self.enclosingBundle.statedPlatformIdentifier
    end

    if !supportedPlatformIdents.kind_of?(Array) || supportedPlatformIdents.count != 1
      EmitIPAPayloadValidationError("#{path.basename.to_s.shellescape}/Info.plist should specify CFBundleSupportedPlatforms with an array containing a single platform, e.g. CFBundleSupportedPlatforms = [ iPhoneOS ], but it has CFBundleSupportedPlatforms = #{supportedPlatformIdents}")
      exit(1)
    end

    platformIdent = supportedPlatformIdents.first.downcase

    # WatchKit 1 app bundle
    platformIdent = "watchos" if platformIdent == "iphoneos" and infoDict["WKWatchKitApp"] == true

    return platformIdent
  end

  def platformIdentifier
    platformIdent = statedPlatformIdentifier

    # Plain resources bundle
    assert(initialized, path.to_s) # assert that we've finalized mutable fields (machoFiles and nestedBundles)
    platformIdent = self.enclosingBundle.platformIdentifier if self.enclosingBundle && self.machoFiles.empty? && self.nestedBundles.empty?

    return platformIdent
  end

  def platform
    return Platform.platformForIdentifer(self.platformIdentifier)
  end

  # Gem::Version
  def deploymentTarget
    return Gem::Version.new(infoDict["MinimumOSVersion"])
  end

  def supportedArchitectures ()
    assert(initialized, path.to_s)
    return @supportedArchs ||= machoFiles.map{ |file| file.machoImages.map{ |mimg| mimg.arch } }.reduce(:&) || []
  end

  def isSpotlightAppExtBundle ()
    extnDict = infoDict["NSExtension"]
    return false unless extnDict
    return extnDict["NSExtensionPointIdentifier"] == "com.apple.spotlight.index"
  end

  def makeDeviceTraitsToDeviceTypesMapForDeviceIdentifiers (identsOfDevicesToThinFor, skipThinDevices, ipa, warnAboutUnsupportedDevices = true)
    # We ask the bundle to figure out the supported platform; we are unable to proceed if we can't determine it.
    platformIdent = self.platformIdentifier()
    FatalError(__LINE__, "Cannot determine the supported platform for bundle at #{path.to_s.shellescape}") unless platformIdent

    # Look up the corresponding platform object.
    platform = Platform.platformForIdentifer(platformIdent)
    FatalError(__LINE__, "Cannot find platform with identifier '#{platformIdent}'") unless platform

    # Determine the sets of device traits that actually matter for this bundle.  For example, if a particular
    # device prefers armv7s and another device prefers armv7, but the bundle contains only armv7, then the thinned
    # payload will be the same for both, and can be used for both devices (at least as far as architectures go).
    # Same thing for the other traits.

    # Go through the device types and build a mapping from trait sets to device lists for the devices for which we
    # will create thinned variants.
    traitSetsToDeviceTypes = {}
    traitSetsToDeviceTypes.default = []
    for deviceType in platform.allKnownDeviceTypes
      # First we check if the device is even selected by the input options; if it isn't, we skip to the next one.
      next if (skipThinDevices && skipThinDevices.include?(deviceType.modelIdent))
      includeDevice = identsOfDevicesToThinFor.include?(deviceType.modelIdent)
      includeDevice |= identsOfDevicesToThinFor.include?(deviceType.productCode)
      includeDevice |= identsOfDevicesToThinFor.include?(deviceType.deviceTraits.artworkDevIdiom)
      includeDevice |= identsOfDevicesToThinFor.include?("all")
      next unless includeDevice

      # Otherwise we know that we want to thin for the device, but we check if we need to modify the device traits
      # based on the bundle payload.  There are two possibilities: either we use a (possibly modified) set of device
      # traits (possibly modified, in case the payload contains something supported but not necessarily preferred by
      # the device traits, e.g. it prefers armv64 but can tolerate armv7), or we get back no device traits at all,
      # in case the device type doesn't support the bundle at all (e.g. an iPhone1,1 cannot run an app that doesn't
      # contain armv6 code).
      bestTraitSet,problemMessage = deviceType.bestDeviceTraitsForBundle(self)

      # It's possible that we couldn't find any device trait set that the device wants and the bundle supports.
      unless bestTraitSet
        EmitWarning(__LINE__, "Device #{deviceType.to_s} isn't supported by the bundle at #{path.to_s.shellescape}: #{problemMessage or "unknown reason"}") if warnAboutUnsupportedDevices
        next
      end

      # If we get this far, we can create a thinned-down version for this type of device.  We add the trait set to
      # the list of ones we want to thin for, if we haven't already seen it, and we add the device to the list of
      # devices for which that trait set is the best fit.
      traitSetsToDeviceTypes[bestTraitSet] |= [ deviceType ]
    end

    if OPTIONS.useAssetutilEql
      assetCatalogs = ipa.thinnableAssetCatalogs
      $stderr.puts "Thinnable AssetCatalogs:"
      $stderr.puts assetCatalogs.map{|x|x.path.to_s}.join("\n").indent
      
      assetTraitGroups = traitSetsToDeviceTypes.keys.sort.group_using { |a,b|
        # .all? is always true when assetCatalogs is empty
        assetCatalogs.all? {|ac|
          ac.eql_for_traits?(a,b)
        }
      }

      $stderr.puts "AssetTraitGroups:"

      for g in assetTraitGroups
        $stderr.puts "---"
        $stderr.puts g.map{|x|x.to_s}.join("\n").indent
        next if g.size == 1
        t0, *tail = *g
        
        for t1 in tail
          devices = traitSetsToDeviceTypes[t1]
          traitSetsToDeviceTypes.delete(t1)

          # This operation coalesces assetutil traits and merges devices with other matching device traits.
          t2 = t1.take_assetutil_traits(t0)
          traitSetsToDeviceTypes[t2] += devices
        end
      end
      
      $stderr.puts "---"
    end
    
    return traitSetsToDeviceTypes
  end

  def infoPropertyListPath ()
    return path + "Info.plist"
  end

  def shouldThin
    return false if isWatchKitStubApp
    return !enclosingBundle || (enclosingBundle.shouldThin && platformIdentifier == enclosingBundle.platformIdentifier)
  end

  def copyToPath (dstPath, thinningTraits = nil, level = 0)
    puts "#{"  "*level}bndl #{name.shellescape} (#{platformIdentifier})" if OPTIONS.verbosity >= 2

    # First remove the existing directory, if any.
    dstPath.rmtree() rescue Errno::ENOENT

    # If our platform is distinct from the native platform of the parent bundle, we disable the thinning traits for
    # this subtree.  This is because in that case, this is actually a payload intended to be sent to another device
    # at a later time, and thinning it would be the wrong thing to do.
    thinningTraits = nil unless self.shouldThin

    # Modify the thinning traits to account for iPhone-only apps in compatibility mode on iPads.
    if thinningTraits and thinningTraits.artworkDevIdiom == "pad" and self.supportedIdioms == ["phone"]
      # It's an iPhone-only app being thinned for iPad.  We do some magic on the thinning traits to reflect the compatibility environment.
      thinningTraits = DeviceTraits.new(thinningTraits.platform, thinningTraits.preferredArch, "phone", thinningTraits.artworkHostedIdioms, 2, 0, thinningTraits.artworkDisplayGamut, thinningTraits.artworkDynamicDisplayMode, thinningTraits.devPerfMemoryClass,thinningTraits.gfxFeatureSetClass, thinningTraits.gfxFeatureSetFallbacks, thinningTraits.featuresToRemove)
      puts "#{"  "*level}  (adjusting thinning traits to #{thinningTraits} for an iPhone-only app on an iPad)" if OPTIONS.verbosity >= 2
    end

    # If we are a Spotlight extension and the thinning traits say that we should strip it out, we skip the copying.
    if self.isSpotlightAppExtBundle() and thinningTraits and thinningTraits.featuresToRemove.include?("spotlight") then
      puts "#{"  "*level}  (skipping copying of a Spotlight Extension on this device)" if OPTIONS.verbosity >= 2
      skipCopying = true
    end

    if thinningTraits && thinningTraits.preferredArch
      thinningTraitsRunnableArchNames = CPUArchitecture.get(thinningTraits.preferredArch).runnable_architectures
      bundleRequiredArch = CPUArchitecture.all.find{|cpuArch| @requiredDevCaps[cpuArch.name] == true }
      if bundleRequiredArch && !thinningTraitsRunnableArchNames.include?(bundleRequiredArch.name)
        puts "#{"  "*level}  (skipping copying of a bundle due to incompatible architecture (thinning for runnable #{thinningTraits.preferredArch}, bundle requires #{bundleRequiredArch.name}))" if OPTIONS.verbosity >= 2
        skipCopying = true
      end
    end

    # Unless we've decided to skip this bundle completely, we copy it now (while possibly thinning).
    unless skipCopying

      # Create the top-level directory and then recurse downward.
      dstPath.mkpath()

      # Copy the file contents to the destination path (possibly applying thinning).
      for subnode in subnodes
        subnode.copyToPath(dstPath + subnode.name, thinningTraits, level + 1)
      end

      # Make the mode of the destination the same as the source.
      dstPath.lchmod(path.stat().mode)

    end

  end

  def thinnableAssetCatalogs
    return self.enumerateTree.select{ |node| node.kind_of?(FSAssetCatalogFileNode) && node.shouldThin }
  end
end

# WatchKit extras
class FSBundleDirectoryNode
  def isWatchKitStubApp
    return self.infoDict["WKWatchKitApp"] == true
  end

  def isWatchKitAppExtension
    return self.infoDict["NSExtension"].kind_of?(Hash) && self.infoDict["NSExtension"]["NSExtensionPointIdentifier"] == "com.apple.watchkit"
  end
end

# Bitcode recompilation extras
class FSBundleDirectoryNode
  def watchAppExChild
    assert(initialized, path.to_s)
    if not defined? @watchAppExChild
      @watchAppExChild = lambda {
        return (if self.isWatchKitStubApp then self.nestedBundles.detect{|b| b.isWatchKitAppExtension } else nil end)
      }.call
    end
    
    return @watchAppExChild
  end
  
  # This is usually the main app in an IPA, but iOS apps which contain watchOS apps will have two roots for bitcode compilation (one for iOS, one for watchOS). In the abstract, bitcode compilation needs to happen in linkage dependency order, so it starts with a tree of bundles and resolves dependencies within that tree. Dependency resolution cannot cross platform boundaries, so a bundle with a new platform becomes a new root.
  def isBitcodeCompilationRootBundle
    if not defined? @isBitcodeCompilationRootBundle
      @isBitcodeCompilationRootBundle = lambda {
        return (!self.enclosingBundle ||
                self.platformIdentifier != self.enclosingBundle.platformIdentifier ||
                self.watchAppExChild != nil)
      }.call
    end
    
    return @isBitcodeCompilationRootBundle
  end
  
  # Find the root bundle (see isBitcodeCompilationRootBundle) for the current tree. E.g. if this bundle is an iOS appex, this method will return the parent iOS app.
  def bitcodeCompilationRootBundle
    if not defined? @bitcodeCompilationRootBundle
      @bitcodeCompilationRootBundle = lambda {
        return (if self.isBitcodeCompilationRootBundle then self else self.enclosingBundle.bitcodeCompilationRootBundle end)
      }.call
    end
    
    return @bitcodeCompilationRootBundle
  end
  
  # Find the root bundle (see isBitcodeCompilationRootBundle and bitcodeCompilationRootBundle), then find the root mach-o from there. It's not necessarily the same as the bundle's mainMachoFile; watchOS apps contain a stub as their mainMachoFile, so the "root" mach-o as far as bitcode compilation is concerned is actually the user's appex (see isWatchKitAppExtension).
  def bitcodeCompilationRootMachO
    assert(initialized, path.to_s)
    if not defined? @bitcodeCompilationRootMachO
      @bitcodeCompilationRootMachO = lambda {
        root = bitcodeCompilationRootBundle
        actualRoot = root.watchAppExChild || root
        return actualRoot.mainMachoFile
      }.call
    end
    
    return @bitcodeCompilationRootMachO
  end
end

# An IPA object represents a directory tree containing the expanded contents of a .ipa file.  The IPA's path is the
# top-level directory.  The mainBundle property is the FSBundleDirectoryNode object that represents the main bundle
# underneath the IPA's Payload directory (if any).
class IPA
  attr  :path           # Pathname for the file in the file system
  attr  :mainBundle     # Reference to the main bundle inside the payload directory
  attr  :vpnPlugins     # Optional vpnplugin bundles inside the payload directory
  attr  :assetPacks     # Array of asset packs in the OnDemandResources directory, if any
  attr  :dsymFiles      # Paths of .dSYM files associated with the IPA (from compiling bitcode)
  attr  :dsymFilesUnthinned # Paths of .dSYM files associated with the IPA (from compiling bitcode) (unthinned, e.g. from a watchOS sub-bundle, this means that they're always in the output IPA)
  attr  :symcacheFiles  # Paths of .symbols files associated with the IPA (from compiling bitcode)
  attr  :symcacheFilesUnthinned  # Paths of .symbols files associated with the IPA (from compiling bitcode) (unthinned, e.g. from a watchOS sub-bundle, this means that they're always in the output IPA)
  attr  :linkageGraph   # LinkageGraph for all the MachOImage objects

  def initialize (path)
    # Scan the file system, constructing the
    path = Pathname(path) unless path.kind_of?(Pathname)
    @path = path

    appPath = payloadPath.children.sort.select{ |chld| chld.extname == ".app" }.first if hasPayload
    @mainBundle = MakeFileSystemNode(appPath, nil, nil, payloadPath) if appPath

    machOs = @mainBundle.enumerateTree.select{|n| n.kind_of?(FSMachOFileNode) }

    # Cache [real path -> MachO] for use below
    machOsByRealPath = Hash[machOs.map{|m| [m.path.realpath, m] }]

    # Setup fallback rpaths for otherwise unresolved linkage. This ensures that we maintain previous behavior (link by name) if we can't resolve @rpaths. This can happen if the app includes a dylib that the executable does not link (maybe it's dlopen'ed instead).
    rpathFallbackStack = machOs.map{|m| LinkageGraph.parent_path_for_macho_binary_or_framework(m.path) }.uniq

    @linkageGraph = LinkageGraph.new

    # Resolve dylibs, starting with executables so that we can get a concrete @executable_path.
    machOs.
      # Partition by executable so that they go first, then flatten so that we process executables and dylibs as one collection.
      partition{|m| m.type == "MH_EXECUTE" }.flatten.
      each{|m|
      m.machoImages.each {|img|
        self.linkageGraph.resolveLoadedDylibs(img, rpathFallbackStack, [], machOsByRealPath)
      }
    }

    $stderr.puts "Complete LinkageGraph:\n#{self.linkageGraph.to_s(mainBundle.path.parent).indent}"

    vpnPluginPaths = payloadPath.children.sort.select{ |chld| chld.extname == ".vpnplugin" } if hasPayload
    @vpnPlugins = vpnPluginPaths.map{|p| MakeFileSystemNode(p, nil, nil, payloadPath) }

    assetPackPaths = assetPacksPath.children.sort.select{ |chld| chld.extname == ".assetpack" } if hasAssetPacks
    @assetPacks = assetPackPaths.collect{ |p| MakeFileSystemNode(p, nil, mainBundle, assetPacksPath) } if assetPackPaths

    @dsymFiles = []
    @dsymFilesUnthinned = []
    @symcacheFiles = []
    @symcacheFilesUnthinned = []
  end

  def payloadPath ()
    return @path + "Payload"
  end

  def assetPacksPath ()
    return @path + "Payload" + "OnDemandResources"
  end

  def symbolCachePath ()
    return @path + "Symbols"
  end

  def bitcodeSymbolMapsPath
    return @path + "BCSymbolMaps"
  end

  def hasPayload ()
    return payloadPath.exist?
  end

  def hasAssetPacks ()
    return assetPacksPath.exist?
  end

  def hasSymbolCache ()
    return symbolCachePath.exist?
  end

  def hasBitcodeSymbolMaps
    bitcodeSymbolMapsPath.exist?
  end

  def thinnableAssetCatalogs
    mainBundleAssetCatalogs = self.mainBundle.thinnableAssetCatalogs
    assetPackAssetCatalogs = (self.assetPacks||[]).map{|ap| ap.thinnableAssetCatalogs }.flatten
    return mainBundleAssetCatalogs + assetPackAssetCatalogs
  end
  
  def appThinningInfoBasename
    return "AppThinning.plist"
  end
  
  def appThinningInfoPath
    return path + appThinningInfoBasename
  end
  
  def appThinningInfoDisplayPath
    return appThinningInfoPath.relative_path_from(path)
  end

  def appThinningInfo
    if not defined? @appThinningInfo
      @appThinningInfo = lambda {
        return Hash.new unless appThinningInfoPath.exist?
        result = CFPropertyList::native_types(LoadUserPlist(appThinningInfoPath, path).value)
        
        unless result.kind_of?(Hash)
          EmitIPAPayloadValidationError("Expected dictionary in: #{appThinningInfoDisplayPath.to_s.shellescape}")
          exit(1)
        end
        
        return result
      }.call
    end
    
    return @appThinningInfo
  end
  
  def stripSwiftSymbols
    if not defined? @stripSwiftSymbols
      @stripSwiftSymbols = lambda {
        keyName = "StripSwiftSymbols"
        value = appThinningInfo[keyName]
        
        case value
        when nil, "1", "YES", 1, true
          return true
        when "0", "NO", 0, false
          return false
        else
          EmitIPAPayloadValidationError("Unexpected value for key #{keyName} in #{appThinningInfoDisplayPath.to_s.shellescape}: #{value}")
          exit(1)
        end
      }.call
    end
    
    return @stripSwiftSymbols
  end
end

def lipo_info(path)
  return CmdSpec.new(locate_tool("lipo"), ["-info", path.to_s]).run(0, true, true)
end

def file_type(path)
  return CmdSpec.new(locate_tool("file"), ["-b", "--", path.to_s]).run(0, true, true).strip
end

#  Examines the file system entity at the path, and returns either a [MachOImage] (if the path refers to
#  a Mach-O file or a symlink to a Mach-O file) or nil (if it doesn't).  The returned MachOImage objects have a path
#  to either the single-architecture or the multi-architecture file so they can in the future   This function always
#  returns a string.
def GetMachOImagesFromOToolInfoForFile (path)
  # Make a quick exit if it doesn't seem like a Mach-O file (or a symlink to one).
  path = Pathname(path) unless path.kind_of?(Pathname)
  return nil unless path.exist? and path.file?
  return nil unless (file_type(path) =~ /Mach-O/ rescue nil)

  # Figure out which architectures it contains.  We end up with 'archs' as either a string if it's a single-architecture
  # Mach-O file, or as an array of strings (which could be even just a single one) if it's a multi-architecture Mach-O.
  output = lipo_info(path)
  
  return nil unless $? == 0
  if output =~ /Architectures in the fat file.*\:(.+)/m
    archs = $1.split
  elsif output =~ /Non-fat file.*\:(.+)/m
    archs = $1.strip
  else
    return nil
  end
  # puts "archs: #{[*archs].join(", ")}"

  # Use otool -h to figure out the Mach-O type.
  output = CmdSpec.new(locate_tool("otool"), ["-h", "-v", "-m", "-arch", "all", path.to_s]).run(0, true, true)
  machOType = /[0-9]+\s+(EXECUTE|DYLIB|BUNDLE)\s+[0-9]+/.match(output)[1] rescue "???"
  # puts "machOType: #{machOType}"

  # Go through the architectures, and construct a Mach-O image for it.
  machoImages = []
  for arch in [ *archs ]
    # Use otool(1) to get the load commands for the architecture, and strip off the first line.
    output = CmdSpec.new(locate_tool("otool"), ["-l", "-v", "-m", "-arch", arch, path]).run(0, true, true)
    output = output.lines.drop(1).join('')

    # Collect load commands.
    loadCommands = nil
    output.split(/Load command \d+\s*\n/).each { |substr|
      # Iterate over the lines in the load command. If we find a section, we deal with it.
      next if substr == ""
      (loadCommands ||= []) << (currentLoadCommand = OpenStruct.new())
      currentSection = nil
      substr.each_line { |line|
        # If the line is "Section", we create a new section.
        if line.strip == "Section"
          # It's the start of a new section.
          (currentLoadCommand["sections"] ||= []) << (currentSection = OpenStruct.new())
        else
          # It's a key value pair, which we add to either the load command or the current section.
          k,v = line.split(' ', 2)
          (currentSection || currentLoadCommand)[k.strip] = v.strip
        end
      }
    }

    # Record the UUID, if there is one.
    uuid = loadCommands.select{ |lc| lc.cmd == "LC_UUID" }.collect{ |lc| lc.uuid }.first
    # p uuid

    # Record the platform and the minimum deployment target.
    versionMinLoadCommandName = loadCommands.select{ |lc| lc.cmd =~ /LC_VERSION_MIN_(.+)/ }.collect{ |lc| lc.cmd }.first
    platformIdentifier = if versionMinLoadCommandName then Platform.platformIdentifierForVersionMinLoadCommand(versionMinLoadCommandName) else nil end
    # p versionMinLoadCommandName
    # p minVersion
    # p sdkVersion

    # Record whether or not there is a code signature.
    hasCodeSignature = loadCommands.select{ |lc| lc.cmd == "LC_CODE_SIGNATURE" }.count > 0
    # p hasCodeSignature

    # Record whether or not there is executable code.
    hasBitcode = loadCommands.select{ |lc| lc.cmd == "LC_SEGMENT" or lc.cmd == "LC_SEGMENT_64" }.find{ |lc|
      # Select segments named "__LLVM" with sections named "__bundle".
      lc.segname == "__LLVM" and lc.sections and lc.sections.find{ |sc| sc.sectname == "__bundle"}
    }
    # p hasBitcode

    # Record whether or not there is bitcode.
    hasExecCode = loadCommands.select{ |lc| lc.cmd == "LC_SEGMENT" or lc.cmd == "LC_SEGMENT_64" }.select{ |lc|
      # Select "__TEXT" segments that aren't zero-sized.
      lc.segname == "__TEXT" and lc.filesize.to_i > 0
    }.count > 0
    # p hasExecCode

    # Finally, create a MachOImage object to represent the Mach-O image.
    machoImages << MachOImage.new("MH_" + machOType, platformIdentifier, arch, uuid, hasBitcode, hasExecCode, hasCodeSignature)
  end

  return machoImages
end


# Examines the file system entity at the path and returns the most specific kind of node that best represents it.
def MakeFileSystemNode (path, parentDirectory = nil, enclosingBundle = nil, parentPathForDisplay = nil)
  # Make a quick exit if the path doesn't even exist.
  path = Pathname(path) unless path.kind_of?(Pathname)
  return nil unless path.exist?

  # Otherwise, what we do depends on the type of file system entity.
  # puts "[#{path}]"
  case path.ftype

  when "file"
    # Check the file name suffix as a first indication of what kind of file it might be.
    case path.extname.downcase
    when ".car"
      magic_type = file_type(path)
      is_bom = magic_type == "Mac OS X bill of materials (BOM) file"
      
      if is_bom
        # If the file type is BOM, then slice accordingly, regardless of the file name (as long as it ends in .car).
        node = FSAssetCatalogFileNode.new(path, enclosingBundle)
      elsif path.basename.to_s.downcase == "assets.car" && path.parent == enclosingBundle.path
        # If the file name is exactly Assets.car and the file type is not BOM, then error (especially if our platforms on devices assume that Assets.car is a BOM file). Â This treats Assets.car as a âreservedâ file name.
        displayPath = if parentPathForDisplay then path.relative_path_from(parentPathForDisplay) else path end
        EmitIPAPayloadValidationError("Assets.car should be an asset catalog, but is \"#{magic_type}\": #{displayPath}")
        exit(1)
      else
        # If the file name is not Assets.car and the file type is not BOM, then skip (i.e., the resource.car case).
        node = FSFileNode.new(path, enclosingBundle)
      end
    else
      # Possibly a Mach-O (we'll need to check the contents to know for sure)
      machoImages = GetMachOImagesFromOToolInfoForFile(path)
      if machoImages && !machoImages.empty? && enclosingBundle && machoImages.first.platformIdentifier == enclosingBundle.statedPlatformIdentifier
        # Instantiate a Mach-O File Node and, if there is an enclosing bundle, add it to the list.
        node = FSMachOFileNode.new(path, enclosingBundle, machoImages)
        enclosingBundle.machoFiles << node if enclosingBundle
      else
        # Otherwise we consider it a regular File Node.
        node = FSFileNode.new(path, enclosingBundle)
      end
    end
    return node

  when "directory"
    # Check if this seems to be a bundle; if so, we get back the Info.plist contents.
    infoDict = FSBundleDirectoryNode.getInfoPlistIfPathIsBundle(path, parentPathForDisplay)
    if infoDict
      # It's a bundle. We instantiate a node, connect it to any enclosing bundle, and set it as the current one.
      node = FSBundleDirectoryNode.new(path, enclosingBundle, infoDict)
      enclosingBundle.nestedBundles << node if enclosingBundle
      bundle = node
    else
      # Not a bundle, so just create a regular directory node.
      node = FSDirectoryNode.new(path, enclosingBundle)
      bundle = enclosingBundle
    end

    # Descend the directory hierarchy.
    for cpath in path.children.sort
      subnode = MakeFileSystemNode(cpath, node, bundle, parentPathForDisplay)
      node.subnodes << subnode if subnode
    end

    # For a bundle directory, we do some post-processing after reading the subtree.
    if node.kind_of?(FSBundleDirectoryNode)
      # Look up the CFBundleExecutable key in the Info dictionary.
      mainExecName = node.infoDict['CFBundleExecutable']

      # If there is a value, we find it in the list of Mach-Os, and set it as the bundle's main Mach-O.
      if mainExecName
        bundle.mainMachoFile = node.subnodes.detect{ |n| n.name.unicode_equal?(mainExecName) }
      end

      node.initialized = true
    end

    # Return the directory node (or specialization of directory node, e.g. bundle node).
    return node

  when "link"
    # Create a symbolic link node.
    return FSSymlinkNode.new(path, enclosingBundle)

  else
    # Any other kind of entity is treated plainly (should we also warn?).
    return FSNode.new(path, enclosingBundle)
  end
end


def WalkBundle (bundle, level = 0)
  puts "#{"  " * level}[#{bundle}] #{bundle.infoDict["CFBundleIdentifier"]} #{bundle.infoDict["CFBundleSupportedPlatforms"]}"
  for machoFile in bundle.machoFiles.each
    puts "#{"  " * level} #{machoFile}"
    for machoImage in machoFile.machoImages
      puts "#{"  " * level} #{machoImage.type} #{machoImage.arch} #{machoImage.uuid}"
    end
  end
  for nestedBundle in bundle.nestedBundles
    WalkBundle(nestedBundle, level + 1)
  end
end


def WalkFiles (node, level = 0)
  puts "#{"  " * level}#{node.class}  #{node}"
  for subnode in (node.subnodes || [])
    WalkFiles(subnode, level + 1)
  end
end


class String

  def quote
    "\"#{self.gsub("\\", "\\\\").gsub("\"", "\\\"")}\""
  end

end


# Validate an unpacked IPA, emitting issues to the JSON.
def ValidateIPA (ipa)
  puts "Validating IPA structure..."

  # First check for basic IPA issues.
  EmitIPAStructureValidationError("IPA has no Payload directory") unless ipa.hasPayload
  EmitIPAStructureValidationError("IPA has no main bundle") unless ipa.mainBundle

  # Then check the main bundle (and any nested subbundles).
  ValidatePayloadBundle(ipa.mainBundle, ipa)

  bundleDisplayPath = ipa.mainBundle.path.relative_path_from(ipa.payloadPath)
  deploymentTarget = ipa.mainBundle.deploymentTarget
  EmitIPAPayloadValidationError("Failed to parse MinimumOSVersion from â#{bundleDisplayPath}/Info.plistâ") if
    !deploymentTarget || deploymentTarget.to_s == "" || !Gem::Version.correct?(deploymentTarget.to_s)
end


# Validate a bundle in the payload of an unpacked IPA, emitting issues to the JSON.
def ValidatePayloadBundle (bundle, ipa, level = 0)
  bundleDisplayPath = bundle.path.relative_path_from(ipa.payloadPath)

  # Check the specific bundle we're given.
  EmitIPAPayloadValidationError("Bundle â#{bundleDisplayPath}â does not specify a platform identifier in its Info.plist") unless bundle.platformIdentifier.nil_if_empty
  
  EmitIPAPayloadValidationError("Info.plist of â#{bundleDisplayPath}â specifies a simulator platform for the CFBundleSupportedPlatforms key") if bundle.platformIdentifier.end_with?("simulator")
  
  platform = Platform.platformForIdentifer(bundle.platformIdentifier)
  EmitIPAPayloadValidationError("Bundle â#{bundleDisplayPath}â specifies an unknown platform in its Info.plist") unless platform
  
  EmitIPAPayloadValidationError("Info.plist of â#{bundleDisplayPath}â specifies WKWatchKitApp=1 but it is an iOS WatchKit extension") if
    bundle.infoDict['CFBundleSupportedPlatforms'] == ["iPhoneOS"] &&
    bundle.infoDict["WKWatchKitApp"] == true &&
    bundle.infoDict["NSExtension"].kind_of?(Hash) &&
    bundle.infoDict["NSExtension"]["NSExtensionPointIdentifier"] == "com.apple.watchkit"

  EmitIPAPayloadValidationError("Info.plist of â#{bundleDisplayPath}â should specify UIDeviceFamily with an array containing one or more entries") if bundle.supportedIdioms.nil_if_empty.nil?
  
  if bundle.isBitcodeCompilationRootBundle
    # It's a main bundle for its platform.  As such, we expect it to have a main Mach-O.
    mainMachoFile = bundle.bitcodeCompilationRootMachO
    if mainMachoFile.nil?
      EmitIPAPayloadValidationError("main bundle #{bundle.path.relative_path_from(ipa.payloadPath)} doesn't have a main Mach-O file")
    elsif !mainMachoFile.kind_of?(FSMachOFileNode)
      $stderr.puts "Main bundle '#{bundle.path.to_s}' main mach-o '#{mainMachoFile.path.to_s}' is of type '#{mainMachoFile.class.name}'"
      EmitIPAPayloadValidationError("main bundle #{bundle.path.relative_path_from(ipa.payloadPath)} specifies a main Mach-O file ('#{mainMachoFile.name}') that isn't an actual Mach-O")
    end
  end

  if platform
    for machoFile in bundle.machoFiles
      if machoFile.machoImages.any?{|mi| mi.hasBitcode }
        out_str, status = Open3.capture2e('bitcode-build-tool',
                                          "-t", (OPTIONS.toolchainDir + "bin").to_s,
                                          "--sdk", platform.sdkPath.to_s,
                                          '--verify', machoFile.path.to_s,
                                          )
        if !status.success?
          if status.exitstatus == 1
            EmitIPAPayloadValidationError("Failed to verify bitcode in #{machoFile.path.relative_path_from(machoFile.path.parent.parent)}:\n" + out_str)
            else
            raise ("bitcode-build-tool failed with #{status}: " + out_str)
          end
        end
      end
    end
  end

  # Recurse through any nested bundles (including, possibly, those of other platforms).
  for subbundle in bundle.nestedBundles
    ValidatePayloadBundle(subbundle, ipa, level + 1)
  end
end


def ValidateOutputIPA (srcIPA, outputIPA, options)
  # There should be no AppThinning plist
  if outputIPA.appThinningInfoPath.exist?
    EmitIPAOutputValidationError("Should have been removed: #{outputIPA.appThinningInfoPath.to_s.shellescape}")
  end
  
  # We should have no remaining bitcode
  for machO in outputIPA.mainBundle.enumerateTree.select{|n| n.kind_of?(FSMachOFileNode) && n.machoImages.any?{|i| i.hasBitcode } }
    EmitIPAOutputValidationError("Found bitcode in #{machO.path}")
  end
  
  # If we compiled bitcode, we should have symbols
  if options.compileBitcode
    dSYMsDir = outputIPA.path + "dSYMs"
    dSYMs = if Dir.exist?(dSYMsDir) then Set.new(Dir.entries(dSYMsDir)) else Set.new() end
    
    symbolsDir = outputIPA.path + "Symbols"
    symbols = if Dir.exist?(symbolsDir) then Set.new(Dir.entries(symbolsDir)) else Set.new() end

    srcMachOs = srcIPA.mainBundle.enumerateTree.select{|n| n.kind_of?(FSMachOFileNode) }
    
    for machO in outputIPA.mainBundle.enumerateTree.select{|n| n.kind_of?(FSMachOFileNode) }
      correspondingInputPath = machO.path.relative_path_from(outputIPA.path)
      correspondingInputMachO = srcMachOs.detect{|n| n.path.relative_path_from(srcIPA.path) == correspondingInputPath }
      assert(correspondingInputMachO, "Could not find macho node with path: #{correspondingInputPath} in #{srcMachOs.map{|n| n.path.relative_path_from(srcIPA.path).to_s }}")
      
      for image in machO.machoImages
        correspondingInputImage = correspondingInputMachO.machoImages.detect{|i| i.arch == image.arch }
        assert(correspondingInputImage, "Couldn't find image for #{image.arch} among #{correspondingInputMachO.machoImages.map{|i|i.arch}}")
        
        if correspondingInputImage.shouldCompileBitcode(options)
          EmitIPAOutputValidationError("Could not find dSYM for: #{machO.path} : #{image.arch}") unless dSYMs.include?(image.uuid + ".dSYM")
          EmitIPAOutputValidationError("Could not find symbols for: #{machO.path} : #{image.arch}") unless symbols.include?(image.uuid + ".symbols")
        end
      end
    end
  end
end


def CreateAssetPackManifest (assetPackDirPath, assetPackManifestFilePath, urlPrefix, parentPathForDisplay = nil)
  # Given a directory full of asset packs, go through them and create a manifest from them.
  assetPackManifestDicts = []
  for assetPackPath in assetPackDirPath.children.sort
    # Skip it if it isn't an asset pack.
    next unless assetPackPath.extname == ".assetpack"

    # Load the Info.plist from the asset pack.
    infoPlist = LoadUserPlist(assetPackDirPath + assetPackPath.basename + "Info.plist", parentPathForDisplay)
    nativeInfoPlist = CFPropertyList::native_types(infoPlist.value) unless infoPlist == nil

    # Here we should check that we have an Info.plist, and that it's well formed.
    next unless nativeInfoPlist

    # Add a dictionary entry to the AssetPackManifest.plist array.
    assetPackManifestDicts << {
      URL: urlPrefix + assetPackPath.basename.to_s,
      bundleKey: nativeInfoPlist["CFBundleIdentifier"] || "",
      isStreamable: true,
    }
  end

  # Emit the AssetPackManifest.plist.
  outputAssetPackManifestPlist = CFPropertyList::List.new
  outputAssetPackManifestPlist.value = CFPropertyList.guess({ "resources" => assetPackManifestDicts })
  outputAssetPackManifestPlist.save(assetPackManifestFilePath, CFPropertyList::List::FORMAT_XML)

end


# Creates an output IPA.  If thinning traits are provided, the output is thinned; otherwise, it's copied as-is.  Asset
# packs can optionally be extracted, and if an URL prefix is provided, an AssetPackManifest.plist can be created. This
# function returns a structure of information describing the created outputs.  This function doesn't deal with bitcode
# in any way; it assumes that bitcode has already been compiled, if needed.   The destination path is first removed if
# it exists, and any ancestor directories are created, if needed.
def CreateOutputIPA (srcIPA, cleanSrcIPA, dstPath, thinningTraits = nil, supportedDevices = nil, extractAssetPacks = false, assetPackManifestURLPrefix = nil, createPlaceholderBundle = false)
  # Create a result struct to contain the output describing the outputs.  It always contains at least the path.
  outputInfo = OpenStruct.new
  outputInfo.path = dstPath
  $stdout.puts "Creating #{thinningTraits ? thinningTraits.to_s : "universal"} IPA contents for #{supportedDevices ? supportedDevices.sort.collect{ |dev| dev.modelIdent }.join(" ") : "all devices"}" if OPTIONS.verbosity >= 1

  # Remove anything that's already at the destination path.
  $stdout.puts "  Removing existing output directory" if dstPath.exist? and OPTIONS.verbosity >= 1
  dstPath.rmtree() rescue Errno::ENOENT

  # Create the output directory, and any ancestor directories.
  $stdout.puts "  Creating directory #{dstPath.to_s.shellescape}" if OPTIONS.verbosity >= 1
  dstPath.mkpath()

  # Copy the main payload bundle.  Whether or not it will be thinned as it is being copied depends on whether or not
  # we were given any thinning traits.
  $stdout.puts "  #{thinningTraits ? "Thinning" : "Copying"} #{srcIPA.mainBundle.name} output payload directory" if OPTIONS.verbosity >= 1
  srcIPA.mainBundle.copyToPath(dstPath + "Payload" + srcIPA.mainBundle.name, thinningTraits, 2)

  srcIPA.vpnPlugins.each{ |vpnPlugin|
    # thinningTraits is intentionally nil. vpnPlugins are signed and we cannot break their signature.
    vpnPlugin.copyToPath(dstPath + "Payload" + vpnPlugin.name, nil, 2)
  }

  # Update the Info.plist of the main payload bundle to contain information about what devices it has been thinned for.
  # We copy only the Info.plist into the placeholder bundle.
  $stdout.puts "    Updating Info.plist with UISupportedDevices keys" if thinningTraits and OPTIONS.verbosity >= 1
  dstInfoPlistPath = dstPath + "Payload" + srcIPA.mainBundle.name + "Info.plist"
  infoPlist = LoadPlist(dstInfoPlistPath)
  nativeInfoPlist = CFPropertyList::native_types(infoPlist.value) unless infoPlist == nil
  nativeInfoPlist[:UISupportedDevices] = supportedDevices.sort.collect{ |dev| dev.modelIdent }.uniq if supportedDevices
  modifiedInfoPlist = CFPropertyList::List.new
  modifiedInfoPlist.value = CFPropertyList.guess(nativeInfoPlist)
  FileUtils.rm_f(dstInfoPlistPath)
  modifiedInfoPlist.save(dstInfoPlistPath, CFPropertyList::List::FORMAT_XML)

  preferred_arch_runnable_archs = thinningTraits ? CPUArchitecture.get(thinningTraits.preferredArch).runnable_architectures : []

  # Also copy any DWARF debug symbols files that are associated with it (generated by compiling bitcode).
  # Depending on our thinning options, we might be copying all of them, or only some.
  
  dsymFiles = (thinningTraits ? srcIPA.dsymFiles.select{ |p| preferred_arch_runnable_archs.include?(p.arch) } : srcIPA.dsymFiles) + srcIPA.dsymFilesUnthinned
  unless dsymFiles.empty?
    # Create a dSYMs directory in the output IPA.
    dsymDirPath = dstPath + "dSYMs"
    dsymDirPath.mkpath()
    $stdout.puts "  Copying .dSYM files to #{dsymDirPath.to_s.shellescape}" if OPTIONS.verbosity >= 1

    # Copy each of the .dSYM files to the dSYMs directory.
    for dsymFile in dsymFiles
      $stdout.puts "    #{dsymFile.basename.to_s.shellescape}" if OPTIONS.verbosity >= 2
      FileUtils.rmtree(dsymDirPath + dsymFile.basename)
      FileUtils.cp_r(dsymFile, dsymDirPath + dsymFile.basename)
    end
  end

  # Also copy any symbol cache files that are associated with it (generated by compiling bitcode).
  # Depending on our thinning options, we might be copying all of them, or only some.
  symcacheFiles = (thinningTraits ? srcIPA.symcacheFiles.select{ |p| preferred_arch_runnable_archs.include?(p.arch) } : srcIPA.symcacheFiles) + srcIPA.symcacheFilesUnthinned
  unless symcacheFiles.empty?
    # Create a Symbols directory in the output IPA.
    symbolsDirPath = dstPath + "Symbols"
    symbolsDirPath.mkpath()
    $stdout.puts "  Copying .symbols files to #{symbolsDirPath.to_s.shellescape}" if OPTIONS.verbosity >= 1

    # Copy each of the .symbols files to the Symbols directory.
    for symcacheFile in symcacheFiles
      $stdout.puts "    #{symcacheFile.basename.to_s.shellescape}" if OPTIONS.verbosity >= 2
      FileUtils.rmtree(symbolsDirPath + symcacheFile.basename)
      FileUtils.cp_r(symcacheFile, symbolsDirPath + symcacheFile.basename)
    end
  end


  # Extract asset packs, if appropriate.
  if srcIPA.hasAssetPacks
    # See if we're supposed to extract them.
    if extractAssetPacks
      # We're extracting asset packs into a directory next to the product, with a "-assetpacks" suffix.
      assetPackOutputDir = dstPath.parent + (dstPath.basename.to_s + "-assetpacks")
      $stdout.puts "  Extracting #{thinningTraits ? "thinned" : "unmodified"} asset packs to #{assetPackOutputDir.to_s.shellescape}" if OPTIONS.verbosity >= 1
      for assetPack in srcIPA.assetPacks
        $stdout.puts "    #{assetPack.name.to_s.shellescape}" if OPTIONS.verbosity >= 2
        assetPack.copyToPath(assetPackOutputDir + assetPack.name, thinningTraits, 2)
      end
      outputInfo.assetPackOutputDir = assetPackOutputDir

      # Emit the AssetPackManifest.plist file, if appropriate.
      if assetPackManifestURLPrefix
        # We will put the asset pack manifest plist into the asset pack output directory.
        assetPackManifestFilePath = assetPackOutputDir + "AssetPackManifest.plist";

        # Now create it from the asset pack directory.
        $stdout.puts "  Creating asset pack manifest plist at #{assetPackManifestFilePath.to_s.shellescape}" if OPTIONS.verbosity >= 1
        CreateAssetPackManifest(assetPackOutputDir, assetPackManifestFilePath, assetPackManifestURLPrefix, srcIPA.payloadPath)

        # Make a note of where the asset pack manifest is.
        outputInfo.assetPackManifestPath = assetPackManifestFilePath
      else
        $stdout.puts "  (not creating an asset pack manifest plist, because no manifest url prefix was provided)" if OPTIONS.verbosity >= 1
      end

    else
      # We're not extracting asset packs, but the original contained them, so we copy them over.
      assetPackOutputDir = dstPath + "Payload" + "OnDemandResources"
      $stdout.puts "  Copying #{thinningTraits ? "thinned" : "unmodified"} asset packs in #{assetPackOutputDir.to_s.shellescape}" if OPTIONS.verbosity >= 1
      for assetPack in srcIPA.assetPacks
        $stdout.puts "    #{assetPack.name.to_s.shellescape}" if OPTIONS.verbosity >= 2
        assetPack.copyToPath(assetPackOutputDir + assetPack.name, thinningTraits, 2)
      end
    end
  end

  # Create the application placeholder bundle, if requested.
  if createPlaceholderBundle
    # The path of the directory containing the placeholder is next to the product, with a "-placeholder" suffix.
    placeholderOutputDir = dstPath.parent + (dstPath.basename.to_s + "-placeholder")
    $stdout.puts "  Creating placeholder app wrapper at #{placeholderOutputDir.to_s.shellescape}" if OPTIONS.verbosity >= 1

    # We first remove any existing entry we find there.
    placeholderOutputDir.rmtree() rescue Errno::ENOENT

    # We create a placeholder bundle inside the directory.
    placeholderAppPath = placeholderOutputDir + srcIPA.mainBundle.name
    $stdout.puts "    Creating main bundle directory #{placeholderAppPath.basename.to_s.shellescape}" if OPTIONS.verbosity >= 1
    placeholderAppPath.mkpath()

    # We copy only the Info.plist into the placeholder bundle.
    $stdout.puts "    Creating placeholder Info.plist" if OPTIONS.verbosity >= 1
    infoPlist = LoadUserPlist(srcIPA.mainBundle.infoPropertyListPath, srcIPA.payloadPath)
    nativeInfoPlist = CFPropertyList::native_types(infoPlist.value) unless infoPlist == nil
    modifiedInfoPlist = CFPropertyList::List.new
    modifiedInfoPlist.value = CFPropertyList.guess(nativeInfoPlist)
    modifiedInfoPlist.save(placeholderAppPath + "Info.plist", CFPropertyList::List::FORMAT_XML)

    # Record the placeholder bundle's path in the output info descriptor.
    outputInfo.placeholderAppPath = placeholderAppPath
  end

  if OPTIONS.validateOutput
    ValidateOutputIPA(cleanSrcIPA, IPA.new(dstPath), OPTIONS)
  end
  
  return outputInfo
end


# We need to compile the bitcode once for each architecture that contains bitcode, and we need to do so in reverse
# dependency order.  This is because a Mach-O can only be compiled when any dynamic library on which it depends has
# already been compiled (or existed as executable code in the first place).  So we use a two-pass approach:  first
# we descend down through the bundle hierarchy, building up lists of Mach-O images to compile.  As we cross platform
# boundaries, we reevaluate whether to compile or strip bitcode.  We compile if we have been asked to do so and if
# the bundle's main executable contains bitcode, otherwise we strip it.  This decision is made for each architec-
# ture, so we end up with two sets: architectures to compile and architectures to strip.  Those two sets should be
# disjoint.  Any architecture that doesn't end up in either set should be omitted.  Mach-O images to that should be
# stripped can be stripped immediately, but those that should be compiled have to be added to a list and compiled
# later, as noted above (we have to compile them in the right order).
def CompileOrStripBitcodeInBundle (ipa, options, bundle, machoImagesToCompile = nil, machoFilesToReassemble = nil, level = 0)
  # If we're at the top level or if we are crossing into a new platform (i.e. if we area looking at a "main bundle"
  # for the platform), we reset our idea of the sets of architectures for which to compile or to strip bitcode.
  if bundle.isBitcodeCompilationRootBundle
    # Start a new list of Mach-O images to compile.  Note that this does not affect the lists that are already
    # being built up by callers.
    machoImagesToCompile = []

    # We also want to keep track of the Mach-O files that we will want to reassemble from compiled or stripped
    # pieces.
    machoFilesToReassemble = []
  end

  # Now go through the Mach-O files in the bundle, looking at each image in turn.
  puts "  #{"|  " * level}#{bundle.path.relative_path_from(ipa.payloadPath)} (identifier: #{bundle.identifier}, platform: #{bundle.platformIdentifier})" if options.verbosity >= 2
  for machoFile in bundle.machoFiles
    # Now go through the Mach-O images in the file, either compiling, stripping, or excluding as appropriate
    # based on its architecture.  We replace the list of Mach-O images with a possibly smaller list.
    puts "  #{"|  " * level}#{machoFile.type.downcase} '#{machoFile.path.relative_path_from(ipa.payloadPath)}'..." if options.verbosity >= 2
    adjustedMachoImages = []
    for machoImage in machoFile.machoImages
      # Exclude this Mach-O image if its architecture isn't one of the ones we want.
      if machoImage.shouldExcludeFromOutput
        puts "  #{"|  " * level}.#{machoImage.arch} (exclude)" if options.verbosity >= 2
        next
      end

      # Otherwise, we first make sure there's a thin Mach-O image file in the output directory (this might
      # use lipo, or might just copy (or hard-link) the file if we already have a thin slice).
      machoImage.thinToPath(machoImage.thinnedPath(ipa, options), level)

      # What we do next depends on whether or not the Mach-O has bitcode.
      if machoImage.shouldCompileBitcode(options)
        # Because we have to compile Mach-Os in dependency order, we defer the actual compilation.
        puts "  #{"|  " * level}.#{machoImage.arch} (compile)" if options.verbosity >= 2
        machoImagesToCompile << machoImage
        
      elsif machoImage.shouldStripBitcode(options)
        # But we can strip bitcode from the binary right away (no need to defer).  We do so in-place.
        puts "  #{"|  " * level}.#{machoImage.arch} (strip)" if options.verbosity >= 2
        CmdSpec.new(locate_tool("bitcode_strip", [machoImage.platform.toolsPath]), [ "-r", "-o", machoImage.thinnedPath(ipa, options), machoImage.thinnedPath(ipa, options) ]).run(level)

        # Strip Swift symbols from Swift dylibs
        if machoImage.machoFile.isSwiftRuntimeDylib && ipa.stripSwiftSymbols
          CmdSpec.new(locate_tool("strip", [machoImage.platform.toolsPath]), [ "-ST", machoImage.thinnedPath(ipa, options) ]).run(level)
        end
        
      else
        # Otherwise, the Mach-O image doesn't have bitcode, so we strip swift symbols and leave the copy we already have alone.
        verb = "copy"
        
        # Strip Swift symbols from Swift dylibs
        if machoImage.machoFile.isSwiftRuntimeDylib && ipa.stripSwiftSymbols
          CmdSpec.new(locate_tool("strip", [machoImage.platform.toolsPath]), [ "-ST", machoImage.thinnedPath(ipa, options) ]).run(level)
          verb = "strip-swift-dylib"
        end
        
        puts "  #{"|  " * level}.#{machoImage.arch} (#{verb})" if options.verbosity >= 2
      end

      # Add the Mach-O image as one that will appear in the universal Mach-O.
      adjustedMachoImages << machoImage

    end  # images

    # Set the list of adjusted Mach-O images as the Mach-O file's new list (excluding any unused images).
    machoFile.machoImages = adjustedMachoImages

    # Also remember that we'll need to re-lipo this Mach-O file for the universal binary.
    machoFilesToReassemble << machoFile

  end  # files

  # Recurse through any subbundles (including, possibly, those of other platforms).  We pass down or context
  # and accumulator containers.
  for subbundle in bundle.nestedBundles
    CompileOrStripBitcodeInBundle(ipa, options, subbundle, machoImagesToCompile, machoFilesToReassemble, level + 1)
  end

  # If we're a main bundle, we do the postprocessing, now that we've dealt with all Mach-Os and all subbundles.
  # This includes compiling any bitcode files that need it (in library dependency order), and reassembling the
  # Mach-O files for use in the universal binary.
  if bundle.isBitcodeCompilationRootBundle
    # Now go through the list of Mach-O images we need to compile.  We process them one architecture at a time.
    # We have already copied bitcode-less executables into a single per-architecture directory, so the bitcode
    # compiler will be able to find them.
    archsToCompile = if options.compileBitcode then bundle.bitcodeCompilationRootMachO.machoImages.select{|i| i.hasBitcode}.map{|i| i.arch} else [] end
    for arch in archsToCompile
      # Get the list of Mach-O images that match the current architecture.
      puts "  #{"|  " * level}Compiling bitcode for #{arch}..." if options.verbosity >= 1
      remainingMachoImagesForArch = machoImagesToCompile.select{ |img| img.arch == arch }

      # Find the first Mach-O image that doesn't link against any Mach-O images that we still need to compile.
      while not remainingMachoImagesForArch.empty?
        # We still have Mach-O images to compile, so we need to find the next one whose dependencies have all
        # been resolved.
        namesOfRemainingMachOs = remainingMachoImagesForArch.select{|image| image.isDylib }.map{ |image| image.machoFile.name }
        machoImage = remainingMachoImagesForArch.select{ |image| (namesOfRemainingMachOs & image.dylibNames) == [] }.first

        # If we found a Mach-O image, we compile it.  If not, it means we hit a dependency cycle.
        if machoImage
          # Compile the bitcode, requesting that a .dSYM also be created in the output directory.  If the IPA has
          # a bitcode symbol deobfuscation map, we also pass it in now.
          machoName = machoImage.machoFile.name
          puts "  #{"|  " * level}  Compiling #{arch} bitcode in '#{machoName.to_s.shellescape}'" if options.verbosity >= 1
          dsymPath = options.tmpDir + "dSYMs" + machoImage.arch + (machoName  + ".dSYM")
          dsymPath.parent.mkpath()
          bitcodeSymbolMap = ipa.bitcodeSymbolMapsPath if ipa.hasBitcodeSymbolMaps
          platformIdent = machoImage.platformIdentifier
          platform = Platform.platformForIdentifer(platformIdent)
          FatalError(__LINE__, "failed to compile bitcode for #{machoName} because we couldn't find the platform with identifier '#{platformIdent}'", platformIdent) unless platform

          # Determine the name of the dSYM file we want.  Initially we don't know its UUID, so we pass in a fixed name, and then we'll rename it once it's been created.
          dsymFile = Pathname(machoImage.thinnedPath(ipa, options).to_s + ".dSYM")

          # Invoke the bitcode-build-tool(1) tool to compile and link the bitcode in the thin Mach-O file.
          begin
            cmdln  = []
            cmdln += [ "-v" ]
            cmdln += [ "-t", options.toolchainDir + "bin" ]

            cmdln += ipa.linkageGraph[machoImage].map{|img| img.thinnedPath(ipa, options).parent }.uniq.map{|p| ["-L", p] }.flatten

            cmdln += [ "--sdk", platform.sdkPath ]
            cmdln += [ "-o", machoImage.thinnedPath(ipa, options) ]
            cmdln += [ "--generate-dsym", dsymFile ] if dsymFile
            cmdln += [ "--symbol-map", bitcodeSymbolMap ] if bitcodeSymbolMap
            cmdln += [ "-j", options.bitcodeCompilationJFactor ] if options.bitcodeCompilationJFactor and options.bitcodeCompilationJFactor > 0

            for opt in options.bitcodeOptions
              cmdln += [ opt ]
            end

            if ipa.stripSwiftSymbols
              cmdln += [ "--strip-swift-symbols" ]
            end

            cmdln += [ machoImage.thinnedPath(ipa, options) ]

            CmdSpec.new(locate_tool("bitcode-build-tool", [machoImage.platform.toolsPath]), cmdln).run(level)
          end

          # Invoke the symbols(1) tool to create a symbol cache.
          begin
            cmdln  = []
            cmdln += [ "-failIfMissingDsym" ] if dsymFile
            cmdln += [ "-symbolsPackageDir", machoImage.thinnedPath(ipa, options).parent ]
            cmdln += [ machoImage.thinnedPath(ipa, options) ]

            CmdSpec.new(locate_tool("symbols", [machoImage.platform.toolsPath]), cmdln).run(level)
            
            # We successfully created the symbol cache file(s).  We don't get told their names, so we scan them all, and figure out which ones are new.
            allSymcacheFiles = machoImage.thinnedPath(ipa, options).parent.children.sort.select{|f| f.extname == ".symbols" }
            newSymcacheFiles = allSymcacheFiles - ipa.symcacheFiles - ipa.symcacheFilesUnthinned

            # Go through the new ones, annotating each one with the architecture, and adding it to the IPA's list of symcache files.
            for symcacheFile in newSymcacheFiles
              # The architecture is the same as the original Mach-O architecture.
              symcacheFile.arch = machoImage.arch
              if machoImage.machoFile.shouldThin
                ipa.symcacheFiles << symcacheFile
              else
                ipa.symcacheFilesUnthinned << symcacheFile
              end
            end
          end

          # If bitcode-build-tool(1) created a .dSYM file, we need to look in it to determine its UUID. Then we rename to it have that UUID.
          if dsymFile
            dsymBinaryPath = dsymFile + "Contents" + "Resources" + "DWARF" + machoName
            dsymImages = GetMachOImagesFromOToolInfoForFile(dsymBinaryPath)
            dsymImageForArch = dsymImages.detect{|i| i.arch == machoImage.arch }
            assert(dsymImageForArch, "Couldn't find image for arch '#{machoImage.arch}' in '#{dsymImages.map{|i|i.arch}}'")
            uuid = dsymImageForArch.uuid

            if uuid.nil_if_empty.nil?
              FatalError(__LINE__, "failed to determine UUID of dSYM file #{dsymFile.to_s.shellescape}")
            else
              # We were able to figure out the path of the dSYM, so we can rename the output file to it.  We annotate it with the architecture.
              newFileName = (uuid + ".dSYM")
              puts "  #{"|  " * level}  Renaming '#{dsymFile}' -> '#{newFileName}')" if options.verbosity >= 2
              newDSYMFile = dsymFile.parent + newFileName
              dsymFile.rename(newDSYMFile)
              dsymFile = newDSYMFile

              # We were successful, so annotate the path of the dsymFile with the architecture, and add it to the IPA's list of dSYMs.
              dsymFile.arch = machoImage.arch
              if machoImage.machoFile.shouldThin
                ipa.dsymFiles << dsymFile
              else
                ipa.dsymFilesUnthinned << dsymFile
              end
            end
          end

          # Dequeue the Mach-O image we compiled, so we can move on to the next one.
          remainingMachoImagesForArch.delete(machoImage)
        else
          # We didn't find a Mach-O image, so we have a cycle.
          log = remainingMachoImagesForArch.map{|image| "\t#{image.machoFile.name}: #{(image.dylibNames & namesOfRemainingMachOs).join(', ')}" }.join("\n")
          FatalError(__LINE__, "failed to compile bitcode: found a cycle involving Mach-Os:\n#{log}")
        end
      end
    end

    # Finally, reassemble universal (multi-architecture) Mach-Os from the thin ones.
    for machoFile in machoFilesToReassemble
      # If we get here, we know that we have thin Mach-Os for every architecture (we exploded them into thin files).
      puts "  #{"|  " * level}Reassembling #{machoFile.path.relative_path_from(ipa.payloadPath)} [#{machoFile.machoImages.map{ |img| img.arch }.join(", ")}]" if options.verbosity >= 2
      univMachoFilePath = machoFile.universalReassemblyPath(ipa, options)
      univMachoFilePath.parent.mkpath()
      if machoFile.machoImages.count == 1
        # We have only a single Mach-O image, so we just copy the thin file instead of creating a universal Mach-O with a single image.
        machoImage = machoFile.machoImages.first
        FileUtils.cp(machoImage.thinnedPath(ipa, options), univMachoFilePath)
        puts "  #{"|  " * level}  [cp #{machoImage.thinnedPath(ipa, options).to_s.shellescape} #{univMachoFilePath.to_s.shellescape}]" if options.verbosity >= 3
      else
        # We have more than one Mach-O image, so we use 'lipo' to put them back together.
        cmdln  = [ "-create" ]
        for machoImage in machoFile.machoImages
          cmdln += [ "-arch", machoImage.arch, machoImage.thinnedPath(ipa, options) ]
        end
        cmdln += [ "-output", univMachoFilePath ]
        
        CmdSpec.new(locate_tool("lipo", [machoFile.platform.toolsPath]), cmdln).run(level, false)
      end
      machoFile.path = univMachoFilePath
    end

  end  # isBitcodeCompilationRootBundle

end


# Main function for processing an unpacked IPA with a set of options.
# The first parameter is a directory containing the unpacked IPA contents, the second parameter is an options OpenStruct.
def ProcessIPA (ipaDir, options)
  # Create a model object to represent the IPA.  This will scan the file system hierarchy and return an object tree.
  puts "Scanning IPA..." if OPTIONS.verbosity >= 1
  ipa = IPA.new(ipaDir)
  
  # Create a new IPA from source, because srcIPA will be mutated
  cleanSrcIPA = if OPTIONS.validateOutput then IPA.new(ipaDir) else nil end
  
  # Check the input.  We always do this, since it's not very expensive and it makes many subsequent errors much clearer.
  ValidateIPA(ipa)
  if $EMITTED_ERRORS
    exit(1)
  end

  # Get a hold of the main bundle.
  mainBundle = ipa.mainBundle

  # If we weren't able to create a main bundle, we cannot proceed.
  if mainBundle == nil
    FatalError(__LINE__, "could not find main bundle in IPA â#{OPTIONS.ipaName}â")
  end
  unless mainBundle.kind_of?(FSBundleDirectoryNode)
    FatalError(__LINE__, "main bundle in IPA â#{OPTIONS.ipaName}â doesn't seem to be well-formed")
  end
  
  JsonOutput[:thinnableAssetCatalogs] = ipa.thinnableAssetCatalogs.map{|x|x.path.to_s}

  # Check that the processing options make sense for the input IPA.  Otherwise we warn about it and disable asset packs.
  if options.createAssetPacks and not ipa.hasAssetPacks
    # We've been asked to create on-demand asset packs but the IPA doesn't contain any.
    EmitWarning(__LINE__, "Asset pack creation requested but IPA doesn't contain any ODR assets; ignoring the request")
    options.createAssetPacks = false
  end

  # Deal with bitcode.  If we've been asked to compile bitcode, we do so.  If we haven't been asked to compile bitcode,
  # but we have been asked to do thinning, we strip bitcode.  We also strip bitcode (instead of compiling it) if we've
  # been asked to compile bitcode but the main exectuable doesn't contain bitcode (this choice is made separately for
  # every platform).
  if options.compileBitcode or options.thinDevices
    # Compile and/or strip any bitcode in the bundle.  This doesn't modify the input; any compiled or stripped binaries
    # are written to the temporary directory, and individual nodes in the node hierarchy are made to point to it.
    puts "#{options.compileBitcode ? "Compiling" : "Stripping"} bitcode..." if options.verbosity >= 1
    CompileOrStripBitcodeInBundle(ipa, options, mainBundle)

    # Explicitly ignore ipa.vpnPlugins. vpnPlugins are signed and we cannot break their signature.
  end

  # Create thinned-out device-specific IPAs, if requested.
  if options.thinDevices
    # First we need to determine the relevant platform; it is the platform of the main bundle.  Embedded bundles may
    # have different platforms (e.g. a WatchKit app embedded inside an iPhoneOS app) but as it is not the main bundle,
    # it will not be thinned.  This is because the type of device on which the main bundle is installed is known at
    # installation time, allowing it to be thinned, the embedded bundle could later be transferred to any supported
    # device (e.g. any type of Apple Watch), so we cannot thin it.


    # Determine the sets of device traits that actually matter for this payload.  For example, if a particular
    # device prefers armv7s and another device prefers armv7, but the payload only has armv7, then the thinned
    # payload will be the same for both, and can be used for both devices (at least as far as architectures go).
    # Same thing for the other traits.
    traitSetsToDeviceTypes = mainBundle.makeDeviceTraitsToDeviceTypesMapForDeviceIdentifiers(OPTIONS.thinDevices, OPTIONS.skipThinDevices, ipa)

    if options.validateOutputZeroVariants && traitSetsToDeviceTypes.empty?
      EmitIPAOutputValidationError("None of the specified thinning devices match the payload")
    end

    # Now iterate over the chosen traits sets and create thinned IPAs.  For each trait set, we also know the list of
    # model identifiers to which that thinned version applies.
    for traitSet, deviceTypes in traitSetsToDeviceTypes
      # Create a device-specific, thinned-out copy of the IPA for the set of traits.

      # We start by determining the name to use for the thin IPA.  We have been requested to obfuscate the name so that
      # people don't try to make assumptions about what they see in it.  The path is specified in the output JSON file,
      # so there should never be a reason for a caller to make assumptions about the specific name.
      traitSetName = Digest::SHA1.hexdigest(traitSet.to_s)

      # Call our main workhorse method to do the heavy lifting.
      outputInfo = CreateOutputIPA(ipa, cleanSrcIPA, options.outputPath + traitSetName, traitSet, deviceTypes, options.createAssetPacks, options.urlPrefix, options.createAppPlaceholders)

      # Make a note about the thinned IPA we created.
      JsonOutput[:thinnedIPAs] = [] unless JsonOutput[:thinnedIPAs]
      JsonOutput[:thinnedIPAs] << {
        path: outputInfo.path,
        containsAssetPacks: (true if ipa.hasAssetPacks and not options.createAssetPacks),
        placeholderAppPath: outputInfo.placeholderAppPath,
        devices: deviceTypes.sort.collect{ |dev| dev.modelIdent },
        traits: {
          architecture: traitSet.preferredArch,
          artworkDevIdiom: traitSet.artworkDevIdiom,
          artworkHostedIdioms: traitSet.artworkHostedIdioms,
          artworkScaleFactor: traitSet.artworkScaleFactor,
          artworkDevSubtype: traitSet.artworkDevSubtype,
          artworkDisplayGamut: traitSet.artworkDisplayGamut,
          artworkDynamicDisplayMode: traitSet.artworkDynamicDisplayMode,
          devPerfMemoryClass: traitSet.devPerfMemoryClass,
          gfxFeatureSetClass: traitSet.gfxFeatureSetClass,
          gfxFeatureSetFallbacks: traitSet.gfxFeatureSetFallbacks,
        },
      }.reject { |k, v| v.nil? }

      if outputInfo.assetPackOutputDir
        # Make a note about the thinned asset packs we created.
        JsonOutput[:thinnedAssetPackSets] = [] unless JsonOutput[:thinnedAssetPackSets]
        JsonOutput[:thinnedAssetPackSets] << {
          path: outputInfo.assetPackOutputDir,
          manifest: outputInfo.assetPackManifestPath,
          devices: deviceTypes.sort.collect{ |dev| dev.modelIdent },
          traits: {
            artworkDevIdiom: traitSet.artworkDevIdiom,
            artworkHostedIdioms: traitSet.artworkHostedIdioms,
            artworkScaleFactor: traitSet.artworkScaleFactor,
            artworkDevSubtype: traitSet.artworkDevSubtype,
            artworkDisplayGamut: traitSet.artworkDisplayGamut,
            artworkDynamicDisplayMode: traitSet.artworkDynamicDisplayMode,
            devPerfMemoryClass: traitSet.devPerfMemoryClass,
            gfxFeatureSetClass: traitSet.gfxFeatureSetClass,
            gfxFeatureSetFallbacks: traitSet.gfxFeatureSetFallbacks,
          },
        }.reject { |k, v| v.nil? }
      end

      puts if OPTIONS.verbosity >= 2
      puts "Created IPA at: #{outputInfo.path.to_s.shellescape}"
      puts "   and ODRs at: #{outputInfo.path.parent + (outputInfo.path.basename.to_s + "-assetpacks")}" if options.createAssetPacks
      puts "   and PLCs at: #{outputInfo.path.parent + (outputInfo.path.basename.to_s + "-placeholder")}" if options.createAppPlaceholders
      puts "   for devices: #{deviceTypes.sort.collect{ |dev| dev.modelIdent + (dev.displayName == dev.modelIdent ? "" : " (" + dev.displayName + ")") }.join("   ")}"
      puts
      puts if OPTIONS.verbosity >= 2
    end
  end

  # Unless we're just being asked for information or validating, we should also create the universal IPA.
  if not OPTIONS.printInfo and not OPTIONS.validateInput
    # Create a device-generic, universal copy of the IPA (though we might have compiled bitcode, and might or might not
    # be extracting asset packs and creating placeholder appwrappers, etc... all we know is that we're not thinning).

    # Call our main workhorse method to do the heavy lifting.
    outputInfo = CreateOutputIPA(ipa, cleanSrcIPA, options.outputPath + "universal", nil, nil, options.createAssetPacks, options.urlPrefix, options.createAppPlaceholders)

    # Make a note about the universal IPA we created.
    JsonOutput[:universalIPA] = {
      path: outputInfo.path,
      containsAssetPacks: (true if ipa.hasAssetPacks and not options.createAssetPacks),
      placeholderAppPath: outputInfo.placeholderAppPath,
    }.reject { |k, v| v.nil? }

    if outputInfo.assetPackOutputDir
      # Make a note about the asset packs we created.
      JsonOutput[:universalAssetPackSet] = {
        path: outputInfo.assetPackOutputDir,
        manifest: outputInfo.assetPackManifestPath,
      }.reject { |k, v| v.nil? }
    end

  end

  # Emit information about the payload, if requested.
  if OPTIONS.printInfo

    # Output the legacy information.
    JsonOutput[:payloadBundleInfo] = []
    for bundle in [ mainBundle ] + mainBundle.nestedBundles
      # Go through the Mach-O files in the bundle.
      puts "  Bundle '#{bundle.identifier}'..."
      for machoFile in bundle.machoFiles
        # Go through the Mach-O images in the file.
        puts "    #{machoFile.type} '#{machoFile.path.relative_path_from(ipa.payloadPath)}'..."
        for machoImage in machoFile.machoImages
          codeTypes = []
          codeTypes << "native" if machoImage.hasExecCode
          codeTypes << "bitcode" if machoImage.hasBitcode
          puts "      #{machoImage.arch} (#{codeTypes.join(" + ")})"
        end
      end
      if ipa.assetPacks
        puts "  Asset Packs:"
        for pack in ipa.assetPacks
          puts"    " + pack.name
        end
      end

      # Emit structured JSON information about the bundle.
      supportedDeviceIdentsToDisplayNames = { }
      for deviceType in bundle.makeDeviceTraitsToDeviceTypesMapForDeviceIdentifiers(["all"], [], ipa, false).values.flatten.sort
        supportedDeviceIdentsToDisplayNames[deviceType.modelIdent] = deviceType.displayName
      end
      JsonOutput[:payloadBundleInfo] << {
        path:  bundle.path,
        identifier: bundle.identifier,
        machoFiles: bundle.machoFiles.collect { |mf| mf.machoImages.collect { |img| img.arch } },
        platform: bundle.platformIdentifier || nil,
        assetPacks: ipa.assetPacks ? ipa.assetPacks.collect { |assetPack| assetPack.name } : nil,
        supportedDevices: supportedDeviceIdentsToDisplayNames,
      }.reject { |k, v| v.nil? }
    end


    def NestedPayloadBundleInfoForJSON (bundle)
      # Construct and return a dictionary of bundle information, including for any nested bundles.
      info = {
        path: bundle.path,
        identifier: bundle.identifier,
        platform: bundle.platformIdentifier,
        isBitcodeCompilationRootBundle: bundle.isBitcodeCompilationRootBundle,
        bitcodeCompilationRootMachO: bundle.bitcodeCompilationRootMachO.path,
        machoFiles: bundle.machoFiles.collect do |mf|
          # Construct a dictionary for the Mach-O file.
          {  path: mf.path,
            slices: mf.machoImages.collect do |img|
              # Construct a dictionary for the Mach-O slice.
              {  type: img.type,
                platform: img.platformIdentifier,
                arch: img.arch,
                uuid: img.uuid,
                dylibNames: img.dylibNames,
                hasExecCode: img.hasExecCode,
                hasBitcode: img.hasBitcode,
                isSigned: img.isSigned,
              }
            end
          }
        end,
      }
      for subbundle in bundle.nestedBundles
        (info[:subbundles] ||= []) << NestedPayloadBundleInfoForJSON(subbundle)
      end
      return info
    end

    # Output the new-style, nested information.
    mainBundleInfo = NestedPayloadBundleInfoForJSON(mainBundle) || []
    JsonOutput[:nestedPayloadBundleInfo] = mainBundleInfo

    # Add asset pack information for the main bundle (not submodules).
    mainBundleInfo[:assetPacks] = ipa.assetPacks.collect { |assetPack| assetPack.name } if ipa.assetPacks

    # Add supported-devices information for the main bundle (not submodules).
    for deviceTraits,deviceTypes in mainBundle.makeDeviceTraitsToDeviceTypesMapForDeviceIdentifiers(["all"], [], ipa, false)
      # We get a dictionary of device traits and a list of device types for a single variant.  We partition it
      # into "device sets".  We never want to mix devices with different traits together, but we want to split
      # out some devices to make things more logical for users.
      for displayName in deviceTypes.sort.collect{ |dev| dev.displayName }.sort.uniq
        (mainBundleInfo[:supportedDeviceSets] ||= []) << {
          displayName: displayName,
          devices: deviceTypes.select{ |dev| dev.displayName == displayName }.sort,
          traits: deviceTraits.to_dict,
        }
      end
    end

  end

  if $EMITTED_ERRORS
    exit(1)
  end
end



class DeviceTraits
  attr_accessor :platform
  attr_accessor :preferredArch
  attr_accessor :artworkDevIdiom
  attr_accessor :artworkHostedIdioms
  attr_accessor :artworkScaleFactor
  attr_accessor :artworkDevSubtype
  attr_accessor :artworkDisplayGamut
  attr_accessor :artworkDynamicDisplayMode
  attr_accessor :devPerfMemoryClass
  attr_accessor :gfxFeatureSetClass
  attr_accessor :gfxFeatureSetFallbacks
  attr_accessor :featuresToRemove

  def initialize (platform, preferredArch, artworkDevIdiom, artworkHostedIdioms, artworkScaleFactor, artworkDevSubtype, artworkDisplayGamut, artworkDynamicDisplayMode, devPerfMemoryClass, gfxFeatureSetClass, gfxFeatureSetFallbacks, featuresToRemove)
    @platform = platform
    @preferredArch = preferredArch
    @artworkDevIdiom = artworkDevIdiom
    @artworkHostedIdioms = artworkHostedIdioms
    @artworkScaleFactor = artworkScaleFactor
    @artworkDevSubtype = artworkDevSubtype
    @artworkDisplayGamut = artworkDisplayGamut
    @artworkDynamicDisplayMode = artworkDynamicDisplayMode
    @devPerfMemoryClass = devPerfMemoryClass
    @gfxFeatureSetClass = gfxFeatureSetClass
    @gfxFeatureSetFallbacks = gfxFeatureSetFallbacks
    @featuresToRemove = featuresToRemove
  end

  def artworkDynamicDisplayMode_1080pSDR
    return "1080pSDR"
  end

  def preferredArchitectureAmongCandidates (availableArchs)
    # Given an array of available architectures, this method returns the one that's preferred.  If none are supported, we return nil.
    return CPUArchitecture.get(preferredArch).runnable_architectures.find{|a| availableArchs.include?(a) }
  end

  def supportedIdioms
    return ([self.artworkDevIdiom] + (if self.artworkDevIdiom == "pad" then ["phone"] else [] end)).sort
  end
  
  def == (other)
    self.to_s == other.to_s
  end

  def <=> (other)
    to_s <=> other.to_s
  end

  def eql? (other)
    return self == other
  end

  def hash
    return to_s.hash
  end

  def to_s
    return "#{platform}|#{preferredArch}|#{artworkDevIdiom}|#{artworkHostedIdioms.join("+")}|#{artworkScaleFactor}x|#{artworkDevSubtype}s|gamut:#{artworkDisplayGamut}|dynamicDisplayMode:#{artworkDynamicDisplayMode}|#{devPerfMemoryClass}m|#{gfxFeatureSetClass}g|#{gfxFeatureSetFallbacks.join("+")}f|#{featuresToRemove.join("+")}"
  end

  def to_dict
    return {
      platform: platform.identifier,
      architecture: preferredArch,
      artworkDevIdiom: artworkDevIdiom,
      artworkHostedIdioms: artworkHostedIdioms,
      artworkScaleFactor: artworkScaleFactor,
      artworkDevSubtype: artworkDevSubtype,
      artworkDisplayGamut: artworkDisplayGamut,
      artworkDynamicDisplayMode: artworkDynamicDisplayMode,
      devPerfMemoryClass: devPerfMemoryClass,
      gfxFeatureSetClass: gfxFeatureSetClass,
      gfxFeatureSetFallbacks: gfxFeatureSetFallbacks,
      featuresToRemove: featuresToRemove
    }.reject { |k, v| v.nil? }
  end

  # [(assetutilFlagName: String, deviceTraitsPropertyName: Symbol, deviceTraitsPropertyValueTransformer: Any -> String)]
  #
  # How do you translate a device traits object for use with assetutil? You need to know which traits correspond to which assetutil flags and how to convert their values to assetutil's representation. This specifies that with a list of triples: the assetutil flag name, the corresponding DeviceTraits property name, and the function needed to convert the property value into a string to be used as an assetutil argument.
  def self.assetutil_translation_map
    id = Proc.new { |value| value.to_s }
    join_colon = Proc.new { |value| value.join(':') }
    join_comma = Proc.new { |value| value.join(',') }
    
    return [
            ["scale", :artworkScaleFactor, id],
            ["idiom", :artworkDevIdiom, id],
            ["subtype", :artworkDevSubtype, id],
            ["display-gamut", :artworkDisplayGamut, id],
            ["memory", :devPerfMemoryClass, id],
            ["graphicsclass", :gfxFeatureSetClass, id],
            ["graphicsclassfallbacks", :gfxFeatureSetFallbacks, join_colon],
            ["hostedidioms", :artworkHostedIdioms, join_comma],
           ]
  end

  # UIDeviceFamily #uidf may be a [String], [Int], or comma-separated String.
  def self.assetutil_idioms_for_UIDeviceFamily(uidf)
    uidf = [uidf].flatten.join(',').split(',').map{|x| x.to_s.strip.nil_if_empty }.compact.sort.uniq
    return uidf.map{|f|
      case f
      when "1"
        "phone"
      when "2"
        "pad"
      when "3"
        "tv"
      when "4"
        "watch"
      else
        raise "Unknown UIDeviceFamily: '#{f}' from '#{uidf}'"
      end
    }
  end

  # Returns a new object with self's properties except for assetutil traits taken from the passed in DeviceTraits object #other.
  def take_assetutil_traits(other)
    ret = self.dup
    for _, sym, _ in self.class.assetutil_translation_map
      ret.instance_variable_set('@' + sym.to_s, other.send(sym))
    end
    
    return ret
  end

  # { assetutilFlag: String => assetutilValue: String ]
  def to_assetutil_dict
    return self.class.assetutil_translation_map.map{|flag,sym,transformer|
      raw_value = self.send(sym)
      next unless raw_value
      
      t_value = transformer.call(raw_value)
      next unless t_value.nil_if_empty
      
      [flag, t_value]
    }.compact.to_h
  end

  # Array representation appropriate for assetutil parameters.
  # E.g. ["--idiom", "pad", "--scale", "1"]
  def to_assetutil_args_array
    if self.artworkDynamicDisplayMode == self.artworkDynamicDisplayMode_1080pSDR
      # We need two sets of args, one with 'scale:1 gamut:srgb' and one with 'scale:2 gamut:p3'

      a = self.dup
      a.artworkDynamicDisplayMode = nil
      a.artworkScaleFactor = 1
      a.artworkDisplayGamut = 'sRGB'
      
      b = self.dup
      b.artworkDynamicDisplayMode = nil
      b.artworkScaleFactor = 2
      b.artworkDisplayGamut = 'P3'
      
      return a.to_assetutil_args_array + b.to_assetutil_args_array
    else
      return self.to_assetutil_dict.to_a.map{|flag, value| ["--" + flag, value] }.flatten
    end
  end

  # String representation appropriate for assetutil -T.
  # E.g.: scale=1:idiom=pad:subtype=0:display-gamut=P3:memory=3:graphicsClass=MTL1,2:deployment=2016
  def to_assetutil_T_string
    skip = ["graphicsclassfallbacks", "hostedidioms"]
    if self.artworkDynamicDisplayMode == self.artworkDynamicDisplayMode_1080pSDR
      # We need two sets of args, one with 'scale:1 gamut:srgb' and one with 'scale:2 gamut:p3'

      a = self.dup
      a.artworkDynamicDisplayMode = nil
      a.artworkScaleFactor = 1
      a.artworkDisplayGamut = 'sRGB'
      
      b = self.dup
      b.artworkDynamicDisplayMode = nil
      b.artworkScaleFactor = 2
      b.artworkDisplayGamut = 'P3'

      return a.to_assetutil_T_string + ":" + b.to_assetutil_T_string
    else
      return self.to_assetutil_dict.delete_if{|k,v| skip.include?(k) }.to_a.map{|tuple| tuple.join('=') }.join(':')
    end
  end
  
end

class DeviceType
  attr  :platform           # e.g. iphoneos
  attr  :productCode        # e.g. m68ap
  attr  :modelIdent         # e.g. iPhone1,1
  attr  :processorIdent     # e.g. s5l8942x
  attr  :deviceTraits       # reference to a DeviceTraits object
  attr  :displayName        # e.g. iPhone 4s

  def initialize (platform, productCode, modelIdent, displayName, processorIdent, deviceTraits)
    @platform = platform
    @productCode = productCode
    @modelIdent = modelIdent
    @processorIdent = processorIdent
    @deviceTraits = deviceTraits
    @displayName = displayName || modelIdent
  end

  def to_s
    return modelIdent
  end

  def <=> (other)
    self.to_s <=> other.to_s
  end

  def bestDeviceTraitsForBundle (bundle)
    # Given a bundle whose supported device traits might not match what we'd prefer, we construct and return a device
    # traits object that represents as good of a match as possible.  If we cannot find one (e.g. if this is an armv7
    # device and the bundle only has arm64 code), we return nil.

    # Note that we also imbue the returned device traits with the features-to-remove for this device (if any).
    return nil,"the bundle doesn't contain any architectures in common among its executables (#{bundle.machoFiles.map{ |file| file.name }.join(", ")})" if bundle.supportedArchitectures.empty?

    # Check the architecture.
    bestArch = deviceTraits.preferredArchitectureAmongCandidates(bundle.supportedArchitectures)
    return nil,"the device doesn't support any of the available architectures (#{bundle.supportedArchitectures.join(", ")})" unless bestArch

    # Check the artwork idiom.
    return nil,"the device doesn't support the app's UIDeviceFamily" unless (deviceTraits.supportedIdioms & bundle.supportedIdioms).size > 0

    bestArtworkDisplayGamut = deviceTraits.artworkDisplayGamut
    if ["iPad6,3", "iPad6,4"].include?(self.modelIdent)
      deploymentTarget = bundle.deploymentTarget
      if deploymentTarget < Gem::Version.new("10.0")
        bestArtworkDisplayGamut = "all"
      end
    end

    # If we get this far, we create a (possibly downshifted)
    return DeviceTraits.new(deviceTraits.platform, bestArch, deviceTraits.artworkDevIdiom, deviceTraits.artworkHostedIdioms,
                            deviceTraits.artworkScaleFactor, deviceTraits.artworkDevSubtype, bestArtworkDisplayGamut, deviceTraits.artworkDynamicDisplayMode, deviceTraits.devPerfMemoryClass,
                            deviceTraits.gfxFeatureSetClass, deviceTraits.gfxFeatureSetFallbacks,
                            deviceTraits.featuresToRemove),nil
  end

end


# Represents a platform, including its identifier, its path, its SDK path, etc.  Right now there's just one platform (iPhone OS),
# since Mac OS X isn't supported.  But if we ever support any other platform, we want to be able to do so by merging in additional
# directories into the Platforms directory and have it all work.
class Platform
  attr  :identifier        # canonical identifier, e.g. iphoneos
  attr  :mainPath          # path of .platform folder itself
  attr  :sdkPath           # path of the SDK to use for the platform
  attr  :toolsPath         # path of platform-specific command line tools
  attr  :deviceTypes       # all known device types (DeviceType objects)

  # Global mapping of platform identifiers to Platform objects.
  @@allKnownPlatformsByIdentifier = nil

  # Returns a hash that maps platform identifier to Platform objects for all known platforms.  Currently there's only iPhoneOS.
  def self.allKnownPlatforms ()
    unless @@allKnownPlatformsByIdentifier
      # Create a hash that we'll add entries to.
      @@allKnownPlatformsByIdentifier = {}

      # Look through the Platforms directory and find subdirectories having a ".platform" suffix.
      for platformDir in OPTIONS.platformsDir.children.sort
        # Skip it if it isn't a platform directory.
        next unless platformDir.extname == ".platform"

        # We can't count on .plists in the platform itself, so we look for an SDK directory with the same name as the platform.
        sdksDir = platformDir + "Developer" + "SDKs"
        sdkDir = sdksDir.children.sort.select{ |dir| dir.basename.to_s =~ /#{platformDir.basename(".platform").to_s}[0-9.]+\.sdk/ and not dir.basename.to_s =~ /[Ss]imulator/ }.sort.last rescue nil

        # Ignore platforms without an interesting SDK.
        unless sdkDir
          EmitWarning(__LINE__, "Configuration issue: platform #{platformDir.basename} doesn't have any non-simulator SDKs; ignoring it")
          next
        end

        # Try to load the 'SDKSettings.plist'. If we cannot find it, it isn't a valid SDK.
        sdk_settings_path = sdkDir + "SDKSettings.plist"
        if !File.exist?(sdk_settings_path)
          EmitWarning(__LINE__, "Configuration issue: platform #{platformDir.basename} doesn't have a '#{sdkDir.basename}' SDK with a SDKSettings.plist; ignoring it. Exception: #{ex.to_log_s}")
          next
        end
        
        sdkSettingsPlist = LoadPlist(sdk_settings_path)

        # Look for the 'CanonicalName' key.
        canonicalNameValue = sdkSettingsPlist.value.value["CanonicalName"] rescue nil
        unless canonicalNameValue
          EmitWarning(__LINE__, "Configuration issue: platform #{platformDir.basename} doesn't have an SDKSettings.plist with a 'CanonicalName' key at the top level")
          next
        end

        platformIdent = canonicalNameValue.value.gsub(/[0-9.]*$/, "")

        # Ignore uninteresting platforms such as Mac OS X.
        next if platformIdent == "macosx"

        # Instantiate a platform and add it to the mapping.
        @@allKnownPlatformsByIdentifier[platformIdent] = Platform.new(platformIdent, platformDir, sdkDir)
      end
    end
    return @@allKnownPlatformsByIdentifier
  end

  ## E.g. LC_VERSION_MIN_IPHONEOS -> iphoneos
  def self.platformIdentifierForVersionMinLoadCommand(loadCommandName)
    case loadCommandName.downcase
    when "lc_version_min_tvos"
      return "appletvos"
    when /^lc_version_min_(.*)$/
      return $1
    else
      raise "Unknown platform for load command: #{loadCommandName}"
    end
  end

  def self.platformForIdentifer (ident)
    return self.allKnownPlatforms[ident]
  end

  def initialize (platformIdent, mainPath, sdkPath)
    # Record the basic information.
    @identifier = platformIdent
    @mainPath = mainPath
    @sdkPath = sdkPath
    @toolsPath = mainPath + "usr" + "bin"

    # Determine the path of the device traits database that defines known devices for the platform.
    deviceTraitsDBPath = mainPath + "usr" + "standalone" + "device_traits.db"

    # Try to load the device types.  Everything having to do with this can fail horribly, so catch exceptions.
    begin
      # Try to open the database from the given path.
      SQLite3::Database.new(deviceTraitsDBPath.to_s, { readonly: true , results_as_hash: true } ) do |db|
        # Load the DeviceTraits.  We create a map from ID numbers to DevTraits objects.
        deviceTraitsByID = {}
        db.execute("select * from DeviceTraits") do |row|
          # Create a DeviceTraits object from the information in the row.
          id = row['DeviceTraitSetID']
          preferredArch = row['PreferredArchitecture']
          artworkDevIdiom = row['ArtworkDeviceIdiom']
          artworkHostedIdioms = (row['ArtworkHostedIdioms'] or "").split(",")
          artworkScaleFactor = row['ArtworkScaleFactor']
          artworkDevSubtype = row['ArtworkDeviceSubtype']
          artworkDisplayGamut = row['ArtworkDisplayGamut']
          artworkDynamicDisplayMode = row['ArtworkDynamicDisplayMode']
          devPerfMemoryClass = row['DevicePerformanceMemoryClass']
          gfxFeatureSetClass = row['GraphicsFeatureSetClass']
          gfxFeatureSetFallbacks = (row['GraphicsFeatureSetFallbacks'] or "").split(":")
          featuresToRemove = (row['FeaturesToRemove'] or "").split(":")
          
          deviceTraitsByID[id] = DeviceTraits.new(self, preferredArch, artworkDevIdiom, artworkHostedIdioms, artworkScaleFactor, artworkDevSubtype, artworkDisplayGamut, artworkDynamicDisplayMode, devPerfMemoryClass, gfxFeatureSetClass, gfxFeatureSetFallbacks, featuresToRemove)
        end
        # Load the DeviceTypes.  We create a map from model identifier strings to the DeviceType objects.
        deviceTypes = []
        db.execute("select * from Devices") do |row|
          # Create a DeviceType object from the information in the row.
          modelIdent = row['ProductType']
          displayName = row['ProductDescription']
          productCode = row['Target']
          processorIdent = row['Platform']
          deviceTraits = deviceTraitsByID[row['DeviceTraitSet']]
          
          deviceTypes << DeviceType.new(self, productCode, modelIdent, displayName, processorIdent, deviceTraits)
        end
        # If we get this far, we were successful, so we record the device types.
        @deviceTypes = deviceTypes.sort
      end
    rescue SQLite3::Exception => exc
      # We failed to populate the database from the sqlite3 file.  We create an empty model-identifers to device-types mapping.
      EmitWarning(__LINE__, "Couldn't load device traits database for platform '#{platformIdent}' from #{deviceTraitsDBPath.to_s.shellescape}; thinning will not work correctly:\n#{exc.to_log_s}")
      @deviceTypes = []
    end
  end

  def to_s
    return identifier
  end

  def <=> (other)
    self.to_s <=> other.to_s
  end

  def allKnownDeviceTypes
    return deviceTypes
  end

end

# Load any platform information we have up-front.  We do this by asking for the mapping.
platforms = Platform.allKnownPlatforms()
FatalError(__LINE__, "couldn't find any platforms at all in #{OPTIONS.platformsDir}") if platforms.empty?

# At this point, the 'inputPath' option always refers to an unpacked IPA.  We process it using the option dictionary we've built it.
ProcessIPA(OPTIONS.inputPath, OPTIONS)

# We're done; we specifically do not flatten the IPA back up, because it still needs to be signed (which is the caller's responsibility).
